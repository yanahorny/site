<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.9 Определение типа</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>   В языке C предусмотрена возможность, называемая typedef
для введения новых имен для типов данных. Например, описание

typedef int length;

делает имя length синонимом для int. &quot;Тип&quot; length может быть
использован в описаниях, переводов типов и т.д. Точно таким
же образом, как и тип int:

   length   len, maxlen;
   length   *lengths[];

Аналогично описанию

    typedef char *string;

делает string синонимом для char*, то есть для указателя на
символы, что затем можно использовать в описаниях вида

    string p, lineptr[LINES], alloc();

    Обратите внимание, что объявляемый в конструкции typedef
тип появляется в позиции имени переменной, а не сразу за
словом typedef. Синтаксически конструкция typedef подобна
описаниям класса памяти extern, static и т. д. Мы также ис-
пользовали прописные буквы, чтобы яснее выделить имена.
    В качестве более сложного примера мы используем конст-
рукцию typedef для описания узлов дерева, рассмотренных ра-
нее в этой главе:

typedef struct tnode {     /* the basic node */
  char *word; /* points to the text */
  int count; /* number of occurrences */
  struct tnode *left;     /* left child */
  struct tnode *right;    /* right child */
} treenode, *treeptr;

В результате получаем два новых ключевых слова: treenode
(структура) и treeptr (указатель на структуру). Тогда функ-
цию talloc можно записать в виде

treeptr talloc()
{
  char *alloc();
  return((treeptr) alloc(sizeof(treenode)));
}

    Необходимо подчеркнуть, что описание typedef не приводит
к созданию нового в каком-либо смысле типа; оно только до-
бавляет новое имя для некоторого существующего типа. При
этом не возникает и никакой новой семантики: описанные таким
способом переменные обладают точно теми же свойствами, что и
переменные, описанные явным образом. По существу конструкция
typedef сходна с #define за исключением того, что она интер-
претируется компилятором и потому может осуществлять подста-
новки текста, которые выходят за пределы возможностей мак-
ропроцессора языка C. Например,

 typedef int (*pfi) ();

создает тип pfi для &quot;указателя функции, возвращающей значе-
ние типа int&quot;, который затем можно было бы использовать в
программе сортировки из главы 5 в контексте вида

pfi strcmp, numcmp, swap;

    Имеются две основные причины применения описаний
typedef. Первая причина связана с параметризацией программы,
чтобы облегчить решение проблемы переносимости. Если для ти-
пов данных, которые могут быть машинно-зависимыми, использо-
вать описание typedef, то при переносе программы на другую
машину придется изменить только эти описания. Одна из типич-
ных ситуаций состоит в использовании определяемых с помощью
typedef имен для различных целых величин и в последующем
подходящем выборе типов short, int и long для каждой имею-
щейся машины.
Второе назначение typedef состоит в обеспечении лучшей доку-
ментации для программы - тип с именем TREEPTR может оказать-
ся более удобным для восприятия, чем тип, который описан
только как указатель сложной структуры.
И наконец, всегда существует вероятность, что в будущем ком-
пилятор или некоторая другая программа, такая как LINT, смо-
жет использовать содержащуюся в описаниях typedef информацию
для проведения некоторой дополнительной проверки программы.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
