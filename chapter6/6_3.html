<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.3 Массивы сруктур</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Структуры особенно подходят для управления массивами
связанных переменных. Рассмотрим, например, программу подс-
чета числа вхождений каждого ключевого слова языка C. Нам
нужен массив символьных строк для хранения имен и массив це-
лых для подсчета. Одна из возможностей состоит в использова-
нии двух параллельных массивов keyword и keycount:

char *keyword [nkeys];
int  keycount [nkeys];

Но сам факт, что массивы параллельны, указывает на возмож-
ность другой организации. Каждое ключевое слово здесь по су-
ществу является парой:

char *keyword;
int  keycount;

и, следовательно, имеется массив пар. Описание структуры

struct key  {
   char *keyword;
   int  keycount;
} keytab [nkeys];

оперделяет массив keytab структур такого типа и отводит для
них память. Каждый элемент массива является структурой. Это
можно было бы записать и так:

struct key  {
   char *keyword;
   int  keycount;
};
struct key keytab [nkeys];

    Так как структура keytab фактически содержит постоянный
набор имен, то легче всего инициализировать ее один раз и
для всех членов при определении. Инициализация структур
вполне аналогична предыдущим инициализациям - за определени-
ем следует заключенный в фигурные скобки список инициализа-
торов:

 struct key  {
    char *keyword;
    int  keycount;
 } keytab[] ={
    &quot;break&quot;, 0,
    &quot;case&quot;, 0,
    &quot;char&quot;, 0,
    &quot;continue&quot;, 0,
    &quot;default&quot;, 0,
    /* ... */
    &quot;unsigned&quot;, 0,
    &quot;while&quot;, 0
 };

Инициализаторы перечисляются парами соответственно членам
структуры. Было бы более точно заключать в фигурные скобки
инициализаторы для каждой &quot;строки&quot; или структуры следующим
образом:

 { &quot;break&quot;, 0 },
 { &quot;case&quot;, 0 },
 . . .

Но когда инициализаторы являются простыми переменными или
символьными строками и все они присутствуют, то во внутрен-
них фигурных скобках нет необходимости. Как обычно, компиля-
тор сам вычислит число элементов массива keytab, если иници-
ализаторы присутствуют, а скобки [] оставлены пустыми.
    Программа подсчета ключевых слов начинается с определе-
ния массива keytab. Ведущая программа читает свой файл вво-
да, последовательно обращаясь к функции getword, которая из-
влекает из ввода по одному слову за обращение. Каждое слово
ищется в массиве keytab с помощью варианта функции бинарного
поиска, написанной нами в главе 3. (Конечно, чтобы эта функ-
ция работала, список ключевых слов должен быть расположен в
порядке возрастания).

 #define    MAXWORD   20

 main()   /* count c keywords */
 {
  int  n, t;
  char word[MAXWORD];
  while ((t = getword(word,MAXWORD)) != EOF)
    if (t == LETTER)
      if((n = binary(word,keytab,nkeys)) &gt;= 0)
        keytab[n].keycount++;
  for (n =0; n &lt; nkeys; n++)
    if (keytab[n].keycount &gt; 0)
      printf(&quot;%4d %s\n&quot;, keytab[n].keycount, keytab[n].keyword);
 }

 binary(word, tab, n) /* find word in tab[0]...tab[n-1] */
 char *word;
 struct key tab[];
 int n;
 {
  int low, high, mid, cond;
  low = 0;
  high = n - 1;
  while (low &lt;= high) {
    mid = (low+high) / 2;
    if((cond = strcmp(word, tab[mid].keyword)) &lt; 0)
     high = mid - 1;
    else if (cond &gt; 0)
     low = mid + 1;
    else
     return (mid);
  }
  return(-1);
 }

Мы вскоре приведем функцию getword; пока достаточно сказать,
что она возвращает LETTER каждый раз, как она находит слово,
и копирует это слово в свой первый аргумент.
    Величина nkeys - это количество ключевых слов в массиве
keytab . Хотя мы можем сосчитать это число вручную, гораздо
легче и надежнее поручить это машине, особенно в том случае,
если список ключевых слов подвержен изменениям. Одной из
возможностей было бы закончить список инициализаторов указа-
нием на нуль и затем пройти в цикле сквозь массив keytab,
пока не найдется конец.
    Но, поскольку размер этого массива полностью определен к
моменту компиляции, здесь имеется более простая возможность.
Число элементов просто есть

size of keytab / size of struct key

дело в том, что в языке C предусмотрена унарная операция
sizeof, выполняемая во время компиляции, которая позволяет
вычислить размер любого объекта. Выражение

sizeof(object)

выдает целое, равное размеру указанного объекта. (Размер оп-
ределяется в неспецифицированных единицах, называемых &quot;бай-
тами&quot;, которые имеют тот же размер, что и переменные типа
char). Объект может быть фактической переменной, массивом и
структурой, или именем основного типа, как int или double,
или именем производного типа, как структура. В нашем случае
число ключевых слов равно размеру массива, деленному на раз-
мер одного элемента массива. Это вычисление используется в
утверждении #define для установления значения nkeys:

#define nkeys (sizeof(keytab) / sizeof(struct key))

    Теперь перейдем к функции getword. Мы фактически написа-
ли более общий вариант функции getword, чем необходимо для
этой программы, но он не на много более сложен. Функция
getword возвращает следующее &quot;слово&quot; из ввода, где словом
считается либо строка букв и цифр, начинающихся с буквы, ли-
бо отдельный символ. Тип объекта возвращается в качетве зна-
чения функции; это - LETTER, если найдено слово, EOF для
конца файла и сам символ, если он не буквенный.

 getword(w, lim)   /* get next word from input */
 char *w;
 int lim;
 {
   int c, t;
   if (type(c=*w++=getch()) !=LETTER) {
     *w='\0';
     return(c);
   }
   while (--lim &gt; 0)  {
     t = type(c = *w++ = getch());
     if (t ! = LETTER &amp;&amp; t ! = DIGIT) {
       ungetch(c);
       break;
   }
 }
   *(w-1) = '\0';
   return(LETTER);
 }

Функция getword использует функции getch и ungetch, которые
мы написали в главе 4: когда набор алфавитных символов пре-
рывается, функция getword получает один лишний символ. В ре-
зультате вызова ungetch этот символ помещается назад во ввод
для следующего обращения.
    Функция getword обращается к функции type для определе-
ния типа каждого отдельного символа из файла ввода. Вот ва-
риант, справедливый только для алфавита ASCII.

  type(c)  /* return type of ascii character */
  int c;
  {
    if (c&gt;= 'a' &amp;&amp; c&lt;= 'z' || c&gt;= 'a' &amp;&amp; c&lt;= 'z')
      return(LETTER);
    else if (c&gt;= '0' &amp;&amp; c&lt;= '9')
      return(DIGIT);
    else
      return(c);
  }

Символические константы LETTER и DIGIT могут иметь любые
значения, лишь бы они не вступали в конфликт с символами,
отличными от буквенно-цифровых, и с EOF; очевидно возможен
следующий выбор

     #define   LETTER   'A'
     #define   DIGIT   '0'

функция getword могла бы работать быстрее, если бы обращения
к функции type были заменены обращениями к соответствующему
массиву type[ ]. В стандартной библиотеке языка C предус-
мотрены макросы isalpha и isdigit, действующие необходимым
образом.

Упражнение 6-1
    Сделайте такую модификацию функции getword и оцените,
как изменится скорость работы программы.

Упражнение 6-2
    Напишите вариант функции type, не зависящий от конкрет-
ного набора символов.

Упражнение 6-3
    Напишите вариант программы подсчета ключевых слов, кото-
рый бы не учитывал появления этих слов в заключенных в ка-
вычки строках.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
