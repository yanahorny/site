<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.6 Поиск в таблице</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Для иллюстрации дальнейших аспектов использования струк-
тур в этом разделе мы напишем программу, представляющую со-
бой содержимое пакета поиска в таблице. Эта программа явля-
ется типичным представителем подпрограмм управления символь-
ными таблицами макропроцессора или компилятора. Рассмотрим,
например, оператор #define языка C. Когда встречается
строка вида

#define YES    1

то имя YES и заменяющий текст 1 помещаются в таблицу. Позд-
нее, когда имя YES появляется в операторе вида

inword = YES;

oно должно быть замещено на 1.
    Имеются две основные процедуры, которые управляют имена-
ми и заменяющими их текстами. Функция install(s,t) записыва-
ет имя s и заменяющий текст t в таблицу; здесь s и t просто
символьные строки. Функция lookup(s) ищет имя s в таблице и
возвращает либо указатель того места, где это имя найдено,
либо NULL, если этого имени в таблице не оказалось.
    При этом используется поиск по алгоритму хеширования -
поступающее имя преобразуется в маленькое положительное чис-
ло, которое затем используется для индексации массива указа-
телей. Элемент массива указывает на начало цепочных блоков,
описывающих имена, которые имеют это значение хеширования.
Если никакие имена при хешировании не получают этого значе-
ния, то элементом массива будет NULL.
    Блоком цепи является структура, содержащая указатели на
соответствующее имя, на заменяющий текст и на следующий блок
в цепи. Нулевой указатель следующего блока служит признаком
конца данной цепи.

struct nlist  {  /* basic table entry */
  char *name;
  char *def;
  struct nlist *next; /* next entry in chain */
};

Массив указателей это просто

 #define    HASHSIZE     100
 static struct nlist *hashtab[HASHSIZE] /* pointer table */

    Значение функции хеширования, используемой обеими функ-
циями lookup и install , получается просто как остаток от
деления суммы символьных значений строки на размер массива.
(Это не самый лучший возможный алгоритм, но его достоинство
состоит в исключительной простоте).

 hash(s)   /* form hash value for string */
 char *s;
 {
  int hashval;
  for (hashval = 0; *s != '\0'; )
    hashval += *s++;
  return(hashval % HASHSIZE);
 }

    В результате процесса хеширования выдается начальный ин-
декс в массиве hashtab ; если данная строка может быть
где-то найдена, то именно в цепи блоков, начало которой ука-
зано там. Поиск осуществляется функцией lookup. Если функция
lookup находит, что данный элемент уже присутствует, то она
возвращает указатель на него; если нет, то она возвращает
NULL.

struct nlist *lookup(s) /* look for s in hashtab */
char *s;
{
  struct nlist *np;
  for (np = hashtab[hash(s)]; np != null; np=np-&gt;next)
    if (strcmp(s, np-&gt;name) == 0)
      return(np);  /* found it */
  return(null);    /* not found */
}

    Функция install использует функцию lookup для определе-
ния, не присутствует ли уже вводимое в данный момент имя;
если это так, то новое определение должно вытеснить старое.
В противном случае создается совершенно новый элемент. Если
по какой-либо причине для нового элемента больше нет места,
то функция install возвращает NULL.

struct nlist *install(name, def) /* put (name, def) */
char *name, *def;
{
  struct nlist *np, *lookup();
  char *strsave(), *alloc();
  int hashval;
  if((np = lookup(name)) == NULL) { /* not found */
    np = (struct nlist *) alloc(sizeof(*np));
    if (np == NULL)
      return(NULL);
    if ((np-&gt;name = strsave(name)) == NULL)
      return(NULL);
    hashval = hash(np-&gt;name);
    np-&gt;next = hashtab[hashval];
    hashtab[hashval] = np;
  } else        /* already there */
    free((np-&gt;def);/* free previous definition */
  if ((np-&gt;def = strsave(def)) == NULL)
    return (NULL);
  return(np);
}

    Функция strsave просто копирует строку, указанную в ка-
честве аргумента, в место хранения, полученное в результате
обращения к функции alloc. Мы уже привели эту функцию в гла-
ве 5. Так как обращение к функции alloc и free могут проис-
ходить в любом порядке и в связи с проблемой выравнивания,
простой вариант функции alloc из главы 5 нам больше не под-
ходит; смотрите главы 7 и 8.

Упражнение 6-7
    Напишите процедуру, которая будет удалять имя и опреде-
ление из таблицы, управляемой функциями lookup и install.

Упражнение 6-8
    Разработайте простую, основанную на функциях этого раз-
дела, версию процессора для обработки конструкций #define ,
пригодную для использования с C-программами. Вам могут
также оказаться полезными функции getchar и ungetch.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
