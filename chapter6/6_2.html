<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.2 Структуры и функции</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    В языке C существует ряд ограничений на использование
структур. Обязательные правила заключаются в том, что единс-
твенные операции, которые вы можете проводить со структура-
ми, состоят в определении ее адреса с помощью операции &amp; и
доступе к одному из ее членов. Это влечет за собой то, что
структуры нельзя присваивать или копировать как целое, и что
они не могут быть переданы функциям или возвращены ими. (В
последующих версиях эти ограничения будут сняты). На указа-
тели структур эти ограничения однако не накладываются, так
что структуры и функции все же могут с удобством работать
совместно. И наконец, автоматические структуры, как и авто-
матические массивы, не могут быть инициализированы; инициа-
лизация возможна только в случае внешних или статических
структур.
    Давайте разберем некоторые из этих вопросов, переписав с
этой целью функции перобразования даты из предыдущей главы
так, чтобы они использовали структуры. Так как правила зап-
рещают непосредственную передачу структуры функции, то мы
должны либо передавать отдельно компоненты, либо передать
указатель всей структуры. Первая возможность демонстрируется
на примере функции day_of_year, как мы ее написали в главе
5:

 d.yearday = day_of_year(d.year, d.month, d.day);

другой способ состоит в передаче указателя. Если мы опишем
hiredate как

 struct  date hiredate;

и перепишем day_of_year нужным образом, мы сможем тогда на-
писать

 hiredate yearday = day_of_year(&amp;hiredate);

передавая указатель на hiredate функции day_of_year. Функ-
ция должна быть модифицирована, потому что ее аргумент те-
перь является указателем, а не списком переменных.

day_of_year(pd) /* set day of year from month, day */
struct date *pd;
{
  int i, day, leap;
  day = pd-&gt;day;
  leap = pd-&gt;year % 4 == 0 &amp;&amp; pd-&gt;year % 100 != 0
    || pd-&gt;year % 400 == 0;
  for (i =1;  i &lt; pd-&gt;month; i++)
    day += day_tab[leap][i];
  return(day);
}

Описание

struct date *pd;

говорит, что pd является указателем структуры типа date.
Запись, показанная на примере

pd-&gt;year

является новой. Если p - указатель на структуру, то
               p-&gt; член структуры
               ------------------
обращается к конкретному члену. (Операция -&gt; - это знак ми-
нус, за которым следует знак &quot;&gt;&quot;.)
    Так как pd указывает на структуру, то к члену year можно
обратиться и следующим образом

 (*pd).year

но указатели структур используются настолько часто, что за-
пись -&gt; оказывается удобным сокращением. Круглые скобки в
(*pd).year необходимы, потому что операция указания члена
стуктуры старше , чем * . Обе операции, &quot;-&gt;&quot; и &quot;.&quot;, ассоции-
руются слева направо, так что конструкции слева и справа
зквивалентны

 p-&gt;q-&gt;memb    (p-&gt;q)-&gt;memb
 emp.birthdate.month    (emp.birthdate).month

Для полноты ниже приводится другая функция, month_day, пере-
писанная с использованием структур.

month_day(pd) /* set month and day from day of year */
struct date *pd;
{
  int i, leap;
  leap = pd-&gt;year % 4 == 0 &amp;&amp; pd-&gt;year % 100 != 0
    || pd-&gt;year % 400 == 0;
  pd-&gt;day = pd-&gt;yearday;
  for (i = 1; pd-&gt;day &gt; day_tab[leap][i]; i++)
    pd-&gt;day -= day_tab[leap][i];
  pd-&gt;month = i;
}

    Операции работы со структурами &quot;-&gt;&quot; и &quot;.&quot; наряду со ()
для списка аргументов и [] для индексов находятся на самом
верху иерархии страшинства операций и, следовательно, связы-
ваются очень крепко. Если, например, имеется описание

 struct {
    int x;
    int *y;
 } *p;

то выражение

 ++p-&gt;x

увеличивает х, а не р, так как оно эквивалентно выражению
++(p-&gt;х). Для изменения порядка выполнения операций можно
использовать круглые скобки: (++p)-&gt;х увеличивает p до дос-
тупа к х, а (p++)-&gt;x увеличивает p после. (Круглые скобки в
последнем случае необязательны. Почему?)
    Совершенно аналогично *p-&gt;y извлекает то, на что указы-
вает y; *p-&gt;y++ увеличивает y после обработки того, на что
он указывает (точно так же, как и *s++); (*p-&gt;y)++ увеличи-
вает то, на что указывает y; *p++-&gt;y увеличивает p после вы-
борки того, на что указывает y.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
