<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.5 Структуры, ссылающиеся на себя</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Предположим, что нам надо справиться с более общей зада-
чей, состоящей в подсчете числа появлений всех слов в неко-
тором файле ввода. Так как список слов заранее не известен,
мы не можем их упорядочить удобным образом и использовать
бинарный поиск. Мы даже не можем осуществлять последователь-
ный просмотр при поступлении каждого слова, с тем чтобы ус-
тановить, не встречалось ли оно ранее; такая программа будет
работать вечно. (Более точно, ожидаемое время работы растет
как квадрат числа вводимых слов). Как же нам организовать
программу, чтобы справиться со списком произвольных слов?
    Одно из решений состоит в том, чтобы все время хранить
массив поступающих до сих пор слов в упорядоченном виде, по-
мещая каждое слово в нужное место по мере их поступления.
Oднако это не следует делать, перемещая слова в линейном
массиве, - это также потребует слишком много времени. Вместо
этого мы используем структуру данных, называемую доичным де-
ревом.
    Каждому новому слову соответствует один &quot;узел&quot; дерева;
каждый узел содержит:
указатель текста слова</PRE>
<HR>
<PRE>
счетчик числа появлений</PRE>
<HR>
<PRE>
указатель узла левого потомка</PRE>
<HR>
<PRE>
указатель узла правого потомка</PRE>
<HR>
<PRE>
Никакой узел не может иметь более двух детей; возможно от-
сутсвие детей или наличие только одного потомка.
    Узлы создаются таким образом, что левое поддерево каждо-
го узла содержит только те слова, которые меньше слова в
этом узле, а правое поддерево только те слова, которые боль-
ше. Чтобы определить, находится ли новое слово уже в дереве,
начинают с корня и сравнивают новое слово со словом, храня-
щимся в этом узле. Если слова совпадают, то вопрос решается
утвердительно. Если новое слово меньше слова в дереве, то
переходят к рассмотрению левого потомка; в противном случае
исследуется правый потомок. Если в нужном направлении пото-
мок отсутствует, то значит новое слово не находится в дереве
и место этого недостающего потомка как раз и является мес-
том, куда следует поместить новое слово. Поскольку поиск из
любого узла приводит к поиску одного из его потомков, то сам
процесс поиска по существу является рекурсивным. В соответс-
твии с этим наиболее естественно использовать рекурсивные
процедуры ввода и вывода.
    Возвращаясь назад к описанию узла, ясно, что это будет
структура с четырьмя компонентами:

struct tnode { /* the basic node */
   char *word; /* points to the text */
   int   count; /* number of occurrences */
   struct tnode *left; /* left child */
   struct tnode *right; /* right child */
};

Это &quot;рекурсивное&quot; описание узла может показаться рискован-
ным, но на самом деле оно вполне корректно. Структура не
имеет права содержать ссылку на саму себя, но

struct tnode *left;

описывает left как указатель на узел, а не как сам узел.
    Текст самой программы оказывается удивительно маленьким,
если, конечно, иметь в распоряжении набор написанных нами
ранее процедур, обеспечивающих нужные действия. Мы имеем в
виду функцию getword для извлечения каждого слова из файла
ввода и функцию alloc для выделения места для хранения слов.
    Ведущая программа просто считывает слова с помощью функ-
ции getword и помещает их в дерево, используя функцию tree.

#define   MAXWORD   20
main()    /* word freguency count */
{
  struct tnode *root, *tree();
  char word[MAXWORD];
  int   t;
  root = NULL;
  while ((t = getword(word, MAXWORD)) != EOF)
    if (t == LETTER)
      root = tree(root, word);
  treeprint(root);
}

    Функция tree сама по себе проста. Слово передается функ-
цией main к верхнему уровню (корню) дерева. На каждом этапе
это слово сравнивается со словом, уже хранящимся в этом уз-
ле, и с помощью рекурсивного обращения к tree просачивается
вниз либо к левому, либо к правому поддереву. В конце концов
это слово либо совпадает с каким-то словом, уже находящимся
в дереве (в этом случае счетчик увеличивается на единицу),
либо программа натолкнется на нулевой указатель, свидетель-
ствующий о необходимости создания и добавления к дереву но-
вого узла. В случае создания нового узла функция tree возв-
ращает указатель этого узла, который помещается в родитель-
ский узел.

 struct tnode *tree(p, w)
 /* install w at or below p */
 struct tnode *p;
 char *w;
 {
   struct tnode *talloc();
   char *strsave();
   int cond;
   if (p == NULL) { /* a new word has arrived */
     p == talloc(); /* make a new node */
     p-&gt;word = strsave(w);
     p-&gt;count = 1;
     p-&gt;left = p-&gt;right = NULL;
   } else if ((cond = strcmp(w, p-&gt;word)) == 0)
     p-&gt;count++;     /* repeated word */
   else if (cond &lt; 0)/* lower goes into left subtree */
     p-&gt;left = tree(p-&gt;left, w);
   else            /* greater into right subtree */
     p-&gt;right = tree(p-&gt;right, w);
   return(p);
 }

    Память для нового узла выделяется функцией talloc, явля-
ющейся адаптацией для данного случая функции alloc, написан-
ной нами ранее. Она возвращает указатель свободного прост-
ранства, пригодного для хранения нового узла дерева. (Мы
вскоре обсудим это подробнее). Новое слово копируется функ-
цией strsave в скрытое место, счетчик инициализируется еди-
ницей, и указатели обоих потомков полагаются равными нулю.
Эта часть программы выполняется только при добавлении нового
узла к ребру дерева. Мы здесь опустили проверку на ошибки
возвращаемых функций strsave и talloc значений (что неразум-
но для практически работающей программы).
    Функция treeprint печатает дерево, начиная с левого под-
дерева; в каждом узле сначала печатается левое поддерево
(все слова, которые младше этого слова), затем само слово, а
затем правое поддерево (все слова, которые старше). Если вы
неуверенно оперируете с рекурсией, нарисуйте дерево сами и
напечатайте его с помощью функции treeprint; это одна из
наиболее ясных рекурсивных процедур, которую можно найти.

 treeprint (p) /* print tree  p  recursively */
 struct tnode *p;
 {
   if (p != NULL)    {
     treeprint (p-&gt;left);
     printf(&quot;%4d %s\n&quot;, p-&gt;count, p-&gt;word);
     treeprint (p-&gt;right);
   }
}

    Практическое замечание: если дерево становится &quot;несба-
лансированным&quot; из-за того, что слова поступают не в случай-
ном порядке, то время работы программы может расти слишком
быстро. В худшем случае, когда поступающие слова уже упоря-
дочены, настоящая программа осуществляет дорогостоящую ими-
тацию линейного поиска. Существуют различные обобщения дво-
ичного дерева, особенно 2-3 деревья и AVL деревья, которые
не ведут себя так &quot;в худших случаях&quot;, но мы не будем здесь
на них останавливаться.
    Прежде чем расстаться с этим примером, уместно сделать
небольшое отступление в связи с вопросом о распределении па-
мяти. Ясно, что в программе желательно иметь только один
распределитель памяти, даже если ему приходится размещать
различные виды объектов. Но если мы хотим использовать один
распределитель памяти для обработки запросов на выделение
памяти для указателей на переменные типа char и для указате-
лей на struct tnode, то при этом возникают два вопроса. Пер-
вый: как выполнить то существующее на большинстве реальных
машин ограничение, что объекты определенных типов должны
удовлетворять требованиям выравнивания (например, часто це-
лые должны размещаться в четных адресах)? Второй: как орга-
низовать описания, чтобы справиться с тем, что функция alloc
должна возвращать различные виды указателей?
    Вообще говоря, требования выравнивания легко выполнить
за счет выделения некоторого лишнего пространства, просто
обеспечив то, чтобы распределитель памяти всегда возвращал
указатель, удовлетворяющий всем ограничениям выравнивания.
Например, на PDP-11 достаточно, чтобы функция alloc всегда
возвращала четный указатель, поскольку в четный адрес можно
поместить любой тип объекта. Единственный расход при этом -
лишний символ при запросе на нечетную длину. Аналогичные
действия предпринимаются на других машинах. Таким образом,
реализация alloc может не оказаться переносимой, но ее ис-
пользование будет переносимым. Функция alloc из главы 5 не
предусматривает никакого определенного выравнивания; в главе
8 мы продемонстрируем, как правильно выполнить эту задачу.
    Вопрос описания типа функции alloc является мучительным
для любого языка, который серьезно относится к проверке ти-
пов. Лучший способ в языке C - объявить, что alloc возвра-
щает указатель на переменную типа char, а затем явно преоб-
разовать этот указатель к желаемому типу с помощью операции
перевода типов. Таким образом, если описать p в виде

    char *p;

то

    (struct tnode *) p

преобразует его в выражениях в указатель на структуру типа
tnode. Следовательно, функцию talloc можно записать в виде:

struct tnode *talloc()
{
  char *alloc();
  return ((struct tnode *) alloc(sizeof(struct tnode)));
}

это более чем достаточно для работающих в настоящее время
компиляторов, но это и самый безопасный путь с учетом будую-
щего.

Упражнение 6-4
    Напишите программу, которая читает C-программу и печа-
тает в алфавитном порядке каждую группу имен переменных, ко-
торые совпадают в первых семи символах, но отличаются где-то
дальше. (Сделайте так, чтобы 7 было параметром).

Упражнение 6-5
    Напишите программу выдачи перекрестных ссылок, т.е.
программу, которая печатает список всех слов документа и для
каждого из этих слов печатает список номеров строк, в кото-
рые это слово входит.

Упражнение 6-6
    Напишите программу, которая печатает слова из своего
файла ввода, расположенные в порядке убывания частоты их по-
явления. Перед каждым словом напечатайте число его появле-
ний.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
