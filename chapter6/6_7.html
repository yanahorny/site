<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>6.7 Поля</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Когда вопрос экономии памяти становится очень существен-
ным, то может оказаться необходимым помещать в одно машинное
слово несколько различных объектов; одно из особенно расп-
росраненных употреблений - набор однобитовых признаков в
применениях, подобных символьным таблицам компилятора. Внеш-
не обусловленные форматы данных, такие как интерфейсы аппа-
ратных средств также зачастую предполагают возможность полу-
чения слова по частям.
    Представьте себе фрагмент компилятора, который работает
с символьной таблицей. С каждым идентификатором программы
связана определенная информация, например, является он или
нет ключевым словом, является ли он или нет внешним и/или
статическим и т.д. Самый компактный способ закодировать та-
кую информацию - поместить набор однобитовых признаков в от-
дельную переменную типа char или int.
    Обычный способ, которым это делается, состоит в опреде-
лении набора &quot;масок&quot;, отвечающих соответствущим битовым по-
зициям, как в

  #define   KEYWORD   01
  #define   EXTERNAL  02
  #define   STATIC    04

(числа должны быть степенями двойки). Тогда обработка битов
сведется к &quot;жонглированию битами&quot; с помощью операций сдвига,
маскирования и дополнения, описанных нами в главе 2.
    Некоторые часто встречающиеся идиомы:

  flags |= EXTERNAL  | STATIC;

включает биты EXTERNAL и STATIC в flags, в то время как

  flags &amp;= ~(ЕXTERNAL | STATIC);

их выключает, а

  if ((flags &amp; (EXTERNAL | STATIC)) == 0) ...

истинно, если оба бита выключены.
    Хотя этими идиомами легко овладеть, язык C в качестве
альтернативы предлагает возможность определения и обработки
полей внутри слова непосредственно, а не посредством побито-
вых логических операций. Поле - это набор смежных битов
внутри одной переменной типа int. Синтаксис определения и
обработки полей основывается на структурах. Например, сим-
вольную таблицу конструкций #define, приведенную выше, можно
бы было заменить определением трех полей:

struct  {
  unsigned is_keyword : 1;
  unsigned is_extern  : 1;
  unsigned is_static  : 1;
}    flags;

Здесь определяется переменная с именем flags, которая содер-
жит три 1-битовых поля. Следующее за двоеточием число задает
ширину поля в битах. Поля описаны как unsigned, чтобы под-
черкнуть, что они действительно будут величинами без знака.
    На отдельные поля можно ссылаться, как flags.is_statie,
flags. is_extern, flags.is_keyword и т.д., то есть точно так
же, как на другие члены структуры. Поля ведут себя подобно
небольшим целым без знака и могут участвовать в арифметичес-
ких выражениях точно так же, как и другие целые. Таким обра-
зом, предыдущие примеры более естественно переписать так:

    flags.is_extern = flags.is_static = 1;

для включения битов;

    flags.is_extern = flags.is_static = 0;

для выключения битов;

    if (flags.is_extern == 0 &amp;&amp;flags.is_static == 0)...

для их проверки.
    Поле не может перекрывать границу int; если указанная
ширина такова, что это должно случиться, то поле выравнива-
ется по границе следующего int. Полям можно не присваивать
имена; неименованные поля (только двоеточие и ширина) ис-
пользуются для заполнения свободного места. Чтобы вынудить
выравнивание на границу следующего int, можно использовать
специальную ширину 0.
    При работе с полями имеется ряд моментов, на которые
следует обратить внимание. По-видимому наиболее существенным
является то, что отражая природу различных аппаратных сред-
ств, распределение полей на некоторых машинах осуществляется
слева направо, а на некоторых справа налево. Это означает,
что хотя поля очень полезны для работы с внутренне опреде-
ленными структурами данных, при разделении внешне определяе-
мых данных следует тщательно рассматривать вопрос о том, ка-
кой конец поступает первым.
    Другие ограничения, которые следует иметь в виду: поля
не имеют знака; они могут храниться только в переменных типа
int (или, что эквивалентно, типа unsigned); они не являются
массивами; они не имеют адресов, так что к ним не применима
операция &amp;.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
