<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>8.7 Пример - распределитель памяти</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    В главе 5 мы написали бесхитростный вариант функции
alloc. Вариант, который мы напишем теперь, не содержит огра-
ничений: обращения к функциям alloc и free могут перемежать-
ся в любом порядке; когда это необходимо, функция alloc об-
ращается к операционной системе за дополнительной памятью.
Кроме того, что эти процедуры полезны сами по себе, они так-
же иллюстрируют некоторые соображения, связанные с написани-
ем машинно-зависимых программ относительно машинно-независи-
мым образом, и показывают практическое применение структур,
объединений и конструкций typedef.
    Вместо того, чтобы выделять память из скомпилированного
внутри массива фиксированного размера, функция alloc будет
по мере необходимости обращаться за памятью к операционной
системе. Поскольку различные события в программе могут тре-
бовать асинхронного выделения памяти, то память, управляемая
alloc, не может быть непрерывной. В силу этого свободная па-
мять хранится в виде цепочки свободных блоков. Каждый блок
включает размер, указатель следующего блока и саму свободную
память. Блоки упорядочиваются в порядке возрастания адресов
памяти, причем последний блок (с наибольшим адресом) указы-
вает на первый, так что цепочка фактически оказывается коль-
цом.
    При поступлении запроса список свободных блоков просмат-
ривается до тех пор, пока не будет найден достаточно большой
блок. Если этот блок имеет в точности требуемый размер, то
он отцепляется от списка и передается пользователю. Если же
этот блок слишком велик, то он разделяется, нужное количест-
во передается пользователю, а остаток возвращается в свобод-
ный список. Если достаточно большого блока найти не удается,
то операционной системой выделяется новый блок, который
включается в список свободных блоков; затем поиск возобнов-
ляется.
    Освобождение памяти также влечет за собой просмотр сво-
бодного списка в поиске подходящего места для введения осво-
божденного блока. Если этот освободившийся блок с какой-либо
стороны примыкает к блоку из списка свободных блоков, то они
объединяются в один блок большего размера, так что память не
становится слишком раздробленной. Обнаружить смежные блоки
просто, потому что свободный список содержится в порядке
возрастания адресов.
    Одна из проблем, о которой мы упоминали в главе 5, зак-
лючается в обеспечении того, чтобы возвращаемая функцией
alloc память была выровнена подходящим образом для тех
объектов, которые будут в ней храниться. Хотя машины и раз-
личаются, для каждой машины существует тип, требующий наи-
больших ограничений по размещению памяти, если данные самого
ограничительного типа можно поместить в некоторый определен-
ный адрес, то это же возможно и для всех остальных типов.
Например, на IBM 360/370, HONEYWELL 6000 и многих других ма-
шинах любой объект может храниться в границах, соответствую-
щим переменным типа double; на PDP-11 будут достаточны пере-
менные типа int.
    Свободный блок содержит указатель следующего блока в це-
почке, запись о размере блока и само свободное пространство;
управляющая информация в начале называется заголовком. Для
упрощения выравнивания все блоки кратны размеру заголовка, а
сам заголовок выровнен надлежащим образом. Это достигается с
помощью объединения, которое содержит желаемую структуру за-
головка и образец наиболее ограничительного по выравниванию
типа:

typedef int align; /*forces alignment on pdp-11*/
union header { /*free block header*/
  struct {
    union header *ptr; /*next free block*/
    unsigned size; /*size of this free block*/
  } s;
  align  x; /*force alignment of blocks*/
};
typedef union header header;

    Функция alloc округляет требуемый размер в символах до
нужного числа единиц размера заголовка; фактический блок,
который будет выделен, содержит на одну единицу больше,
предназначаемую для самого заголовка, и это и есть значение,
которое записывается в поле size заголовка. Указатель, возв-
ращаемый функцией alloc, указывает на свободное пространст-
во, а не на сам заголовок.

static header base; /*empty list to get started*/
static header *allocp=NULL; /*last allocated block*/

char *alloc(nbytes) /*general-purpose storage allocator*/
unsigned nbytes;
{
  header *morecore();
  register header *p, *g;
  register int nunits;
  nunits = 1+(nbytes+sizeof(header)-1)/sizeof(header);
  if( (g=allocp)==NULL ) { /*no free list yet*/
    base.s.ptr=allocp=g=&base;
    base.s.size=0;
  }
  for (p = g->s.ptr; ; g = p, p = p->s.ptr) 
  {
    if (p->s.size >= nunits) { /*big enough*/
      if (p->s.size == nunits) /*exactly*/
        g->s.ptr = p->s.ptr;
      else { /*allocate tail end*/
        p->s.size -= nunits;
        p += p->s.size;
        p->s.size = nunits;
      }
      allocp = g;
      return( (char *)(p+1) );
    }
    if( p == allocp ) /*wrapped around free list*/
      if( (p = morecore(nunits)) == NULL )
        return(NULL); /*none left*/
  } // for
}

    Переменная base используется для начала работы. Если
allocp имеет значение NULL, как в случае первого обращения к
alloc, то создается вырожденный свободный список: он состоит
из свободного блока размера нуль и указателя на самого себя.
В любом случае затем исследуется свободный список. Поиск
свободного блока подходящего размера начинается с того места
(allocp), где был найден последний блок; такая стратегия по-
могает сохранить однородность диска. Если найден слишком
большой блок, то пользователю предлагается его хвостовая
часть; это приводит к тому, что в заголовке исходного блока
нужно изменить только его размер. Во всех случаях возвращае-
мый пользователю указатель указывает на действительно сво-
бодную область, лежащую на единицу дальше заголовка. Обрати-
те внимание на то, что функция alloc перед возвращением "p"
преобразует его в указатель на символы.
    Функция morecore получает память от операционной систе-
мы. Детали того, как это осуществляется, меняются, конечно,
от системы к системе. На системе UNIX точка входа sbrk(n)
возвращает указатель на "n" дополнительных байтов памя-
ти (указатель удволетворяет всем ограничениям на выравнива-
ние). Так как запрос к системе на выделение памяти является
сравнительно дорогой операцией, мы не хотим делать это при
каждом обращении к функции alloc. Поэтому функция morecore
округляет затребованное число единиц до большего значения;
этот больший блок будет затем разделен так, как необходимо.
Масштабирующая величина является параметром, который может
быть подобран в соответствии с необходимостью.

#define NALLOC 128 /*#units to allocate at once*/
static header *morecore(nu) /*ask system for memory*/
unsigned nu;
{
  char *sbrk();
  register char *cp;
  register header *up;
  register int rnu;
  rnu=NALLOC*((nu+NALLOC-1)/NALLOC);
  cp=sbrk(rnu*sizeof(header));
  if ((int)cp==-1) /*no space at all*/
    return(NULL);
  up=(header *)cp;
  up->s.size=rnu;
  free((char *)(up+1));
  return(allocp);
}

    Если больше не осталось свободного пространства, то фун-
кция sbrk возвращает "-1", хотя NULL был бы лучшим выбором.
Для надежности сравнения "-1" должна быть преобразована к
типу int. Снова приходится многократно использовать явные
преобразования (перевод) типов, чтобы обеспечить определен-
ную независимость функций от деталей представления указате-
лей на различных машинах.
    И последнее - сама функция free. Начиная с allocp, она
просто просматривает свободный список в поиске места для
введения свободного блока. Это место находится либо между
двумя существующими блоками, либо в одном из концов списка.
В любом случае, если освободившийся блок примыкает к одному
из соседних, смежные блоки объединяются. Следить нужно толь-
ко затем, чтобы указатели указывали на то, что нужно, и что-
бы размеры были установлены правильно.

free(ap) /*put blocke ap in free list*/
char *ap;
{
  register header *p, *g;
  p = (header*)ap - 1; /*point to header*/
  for( g = allocp; !(p>g &amp;&amp; p>g->s.ptr); g = g->s.ptr)
    if( g >= g->s.ptr &amp;&amp; (p>g || p&lt;g->s.ptr) )
      break; /*at one end or other*/
  if( p + p->s.size == g->s.ptr ) { /*join to upper nbr*/
    p->s.size += g->s.ptr->s.size;
    p->s.ptr = g->s.ptr->s.ptr;
  }
  else
    p->s.ptr = g->s.ptr;
  if( g + g->s.size == p ) { /*join to lower nbr*/
    g->s.size += p->s.size;
    g->s.ptr = p->s.ptr;
  }
  else
    g->s.ptr = p;
  allocp = g;
}

    Хотя распределение памяти по своей сути зависит от ис-
пользуемой машины, приведенная выше программа показывает,
как эту зависимость можно регулировать и ограничить весьма
небольшой частью программы. Использование typedef и union
позволяет справиться с выравниванием (при условии, что функ-
ция sbrk обеспечивает подходящий указатель). Переводы типов
организуют выполнение явного преобразования типов и даже
справляются с неудачно разработанным системным интерфейсом.
И хотя рассмотренные здесь подробности связаны с распределе-
нием памяти, общий подход равным образом применим и к другим
ситуациям.

Упражнение 8-6
    Функция из стандартной библиотеки calloc(n,size) возвра-
щает указатель на "n" объектов размера size, причем соответ-
ствующая память инициализируется на нуль. Напишите программу
для calloc, используя функцию alloc либо в качестве образца,
либо как функцию, к которой происходит обращение.

Упражнение 8-7
    Функция alloc принимает затребованный размер, не прове-
ряя его правдоподобности; функция free полагает, что тот
блок, который она должна освободить, содержит правильное
значение в поле размера. Усовершенствуйте эти процедуры,
затратив больше усилий на проверку ошибок.

Упражнение 8-8
    Напишите функцию bfree(p,n), которая включает произволь-
ный блок "p" из "n" символов в список свободных блоков, уп-
равляемый функциями alloc и free. С помощью функции bfree
пользователь может в любое время добавлять в свободный спи-
сок статический или внешний массив.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
