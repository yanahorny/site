<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>8.2 Низкоуровневый ввод/вывод - операторы read и write</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Самый низкий уровень ввода/вывода в системе UNIX не пре-
дусматривает ни какой-либо буферизации, ни какого-либо дру-
гого сервиса; он по существу является непосредственным вхо-
дом в операционную систему. Весь ввод и вывод осуществляется
двумя функциями: read и write. Первым аргументом обеих функ-
ций является дескриптор файла. Вторым аргументом является
буфер в вашей программе, откуда или куда должны поступать
данные. Третий аргумент - это число подлежащих пересылке
байтов. Обращения к этим функциям имеют вид:

n_read=read(fd,buf,n);
n_written=write(fd,buf,n);

При каждом обращении возвращается счетчик байтов, указываю-
щий фактическое число переданных байтов. При чтении возвра-
щенное число байтов может оказаться меньше, чем запрошенное
число. Возвращенное нулевое число байтов означает конец фай-
ла, а "-1" указывает на наличие какой-либо ошибки. При запи-
си возвращенное значение равно числу фактически записанных
байтов; несовпадение этого числа с числом байтов, которое
предполагалось записать, обычно свидетельствует об ошибке.
    Количество байтов, подлежащих чтению или записи, может
быть совершенно произвольным. Двумя самыми распространенными
величинами являются "1", которая означает передачу одного
символа за обращение (т.е. без использования буфера), и
"512", которая соответствует физическому размеру блока на
многих периферийных устройствах. Этот последний размер будет
наиболее эффективным, но даже ввод или вывод по одному сим-
волу за обращение не будет необыкновенно дорогим.
    Объединив все эти факты, мы написали простую программу
для копирования ввода на вывод, эквивалентную программе ко-
пировки файлов, написанной в главе 1. На системе UNIX эта
программа будет копировать что угодно куда угодно, потому
что ввод и вывод могут быть перенаправлены на любой файл или
устройство.

#define bufsize 512 /*best size for pdp-11 unix*/
main() /*copy input to output*/
{
  char buf[BUFSIZE];
  int n;
  while((n=read(0,buf,BUFSIZE))>0)
  write(1,buf,n);
}

Если размер файла не будет кратен BUFSIZE, то при некотором
обращении к read будет возвращено меньшее число байтов, ко-
торые затем записываются с помощью write; при следующем пос-
ле этого обращении к read будет возвращен нуль.
    Поучительно разобраться, как можно использовать функции
read и write для построения процедур более высокого уровня,
таких как getchar, putchar и т.д. Вот, например, вариант
функции getchar, осуществляющий ввод без использования буфе-
ра.

#define CMASK 0377 /*for making char's > 0*/
getchar() /*unbuffered single character input*/
{
  char c;
  return((read(0,&amp;c,1)&gt;0 ? c &amp; CMASK : EOF);
}

Переменная c должна быть описана как char, потому что фун-
кция read принимает указатель на символы. Возвращаемый сим-
вол должен быть маскирован числом 0377 для гарантии его по-
ложительности; в противном случае знаковый разряд может сде-
лать его значение отрицательным. (Константа 0377 подходит
для ЭВМ PDP-11, но не обязательно для других машин).
    Второй вариант функции getchar осуществляет ввод больши-
ми порциями, а выдает символы по одному за обращение.

#define CMASK 0377 /*for MAKING char's>0*/
#define BUFSIZE 512

getchar() /*buffered version*/
{
  static char  buf[BUFSIZE];
  static char  *bufp = buf;
  static int   n = 0;
  if (n==0) { /*buffer is empty*/
    n=read(0,buf,BUFSIZE);
    bufp = buf;
  }
  return((--n>=0) ? *bufp++ &amp; CMASK : EOF);
}</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
