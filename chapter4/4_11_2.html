<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.11.2 Mакроподстановка</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Определение вида

 #define YES     1

приводит к макроподстановке самого простого вида - замене
имени на строку символов. Имена в #define имеют ту же самую
форму, что и идентификаторы в C; заменяющий текст совер-
шенно произволен. Нормально заменяющим текстом является ос-
тальная часть строки; длинное определение можно продолжить,
поместив \ в конец продолжаемой строки. "Область действия"
имени, определенного в #define, простирается от точки опре-
деления до конца исходного файла. Имена могут быть переопре-
делены, и определения могут использовать определения, сде-
ланные ранее. Внутри заключенных в кавычки строк подстановки
не производятся, так что если, например, YES - определенное
имя, то в printf("YES") не будет сделано никакой подстанов-
ки.
    Так как реализация #define является частью работы
макропредпроцессора, а не собственно компилятора, имеется
очень мало грамматических ограничений на то, что может быть
определено. Так, например, любители Алгола могут объявить

#define THEN
#define BEGIN {
#define END   ;}

и затем написать

if (i > 0) THEN
   BEGIN
      a = 1;
      b = 2
   END

    Имеется также возможность определения макроса с аргумен-
тами, так что заменяющий текст будет зависеть от вида обра-
щения к макросу. Определим, например, макрос с именем max
следующим образом:

#define max(a, b)  ((a) > (b) ? (a) : (b))

когда строка

x = max(p+q, r+s);

будет заменена строкой

x = ((p+q) > (r+s) ? (p+q) : (r+s));

Такая возможность обеспечивает "функцию максимума", которая
расширяется в последовательный код, а не в обращение к функ-
ции. При правильном обращении с аргументами такой макрос бу-
дет работать с любыми типами данных; здесь нет необходимости
в различных видах max для данных разных типов, как это было
бы с функциями.
    Конечно, если вы тщательно рассмотрите приведенное выше
расширение max, вы заметите определенные недостатки. Выраже-
ния вычисляются дважды; это плохо, если они влекут за собой
побочные эффекты, вызванные, например, обращениями к функци-
ям или использованием операций увеличения. Нужно позаботить-
ся о правильном использовании круглых скобок, чтобы гаранти-
ровать сохранение требуемого порядка вычислений. (Рассмотри-
те макрос

  #define square(x)  x * x

при обращении к ней, как square(z+1)). Здесь возникают даже
некоторые чисто лексические проблемы: между именем макро и
левой круглой скобкой, открывающей список ее аргументов, не
должно быть никаких пробелов.
    Тем не менее аппарат макросов является весьма ценным.
Один практический пример дает описываемая в главе 7 стандар-
тная библиотека ввода-вывода, в которой getchar и putchar
определены как макросы (очевидно putchar должна иметь аргу-
мент), что позволяет избежать затрат на обращение к функции
при обработке каждого символа.
    Другие возможности макропроцессора описаны в приложении
А.

Упражнение 4-9
    Определите макрос swap(x, y), который обменивает значе-
ниями два своих аргумента типа int. (В этом случае поможет
блочная структура).</pre>

	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
