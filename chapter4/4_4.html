<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.4 Внешние переменные</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Программа на языке C состоит из набора внешних объек-
тов, которые являются либо переменными, либо функциями. Тер-
мин "внешний" используется главным образом в противопостав-
ление термину "внутренний", которым описываются аргументы и
автоматические переменные, определенные внурти функций.
Внешние переменные определены вне какой-либо функции и, та-
ким образом, потенциально доступны для многих функций. Сами
функции всегда являются внешними, потому что правила языка
C не разрешают определять одни функции внутри других. По
умолчанию внешние переменные являются также и "глобальными",
так что все ссылки на такую переменную, использующие одно и
то же имя (даже из функций, скомпилированных независимо),
будут ссылками на одно и то же. В этом смысле внешние пере-
менные аналогичны переменным COМMON в  Фортране и EXTERNAL в
PL/1. Позднее мы покажем, как определить внешние переменные
и функции таким образом, чтобы они были доступны не глобаль-
но, а только в пределах одного исходного файла.
    В силу своей глобальной доступности внешние переменные
предоставляют другую, отличную от аргументов и возвращаемых
значений, возможность для обмена данными между функциями.
Если имя внешней переменной каким-либо образом описано, то
любая функция имеет доступ к этой переменной, ссылаясь к ней
по этому имени.
    В случаях, когда связь между функциями осуществляется с
помощью большого числа переменных, внешние переменные оказы-
ваются более удобными и эффективными, чем использование
длинных списков аргументов. Как, однако, отмечалось в главе
1, это соображение следует использовать с определенной осто-
рожностью, так как оно может плохо отразиться на структуре
программ и приводить к программам с большим числом связей по
данным между функциями.
    Вторая причина использования внешних переменных связана
с инициализацией. В частности, внешние массивы могут быть
инициализированы а автоматические нет. Мы рассмотрим вопрос
об инициализации в конце этой главы.
    Третья причина использования внешних переменных обуслов-
лена их областью действия и временем существования. Автома-
тические переменные являются внутренними по отношению к фун-
кциям; они возникают при входе в функцию и исчезают при вы-
ходе из нее. Внешние переменные, напротив, существуют посто-
янно. Они не появляются и не исчезают, так что могут сохра-
нять свои значения в период от одного обращения к функции до
другого. В силу этого, если две функции используют некоторые
общие данные, причем ни одна из них не обращается к другой,
то часто наиболее удобным оказывается хранить эти общие дан-
ные в виде внешних переменных, а не передавать их в функцию
и обратно с помощью аргументов.
    Давайте продолжим обсуждение этого вопроса на большом
примере. Задача будет состоять в написании другой программы
для калькулятора, лучшей, чем предыдущая. Здесь допускаются
операции +,-,*,/ и знак = (для выдачи ответа). Вместо инфикс-
ного представления калькулятор будет использовать обратную
польскую нотацию, поскольку ее несколько легче реализовать. В
обратной польской нотации знак следует за операндами; инфик-
сное выражение типа

   (1-2)*(4+5)=

  записывается в виде

   12-45+*=

  круглые скобки при этом не нужны

    Реализация оказывается весьма простой. Каждый операнд по-
мещается в стек; когда поступает знак операции, нужное число
операндов (два для бинарных операций) вынимается, к ним при-
меняется операция и результат направляется обратно в
стек. Так в приведенном выше примере 1 и 2 помещаются в стек
и затем заменяются их разностью, -1. После этого 4 и 5 вво-
дятся в стек и затем заменяются своей суммой, 9. Далее числа
-1 и 9 заменяются в стеке на их произведение, равное -9. Опе-
рация = печатает верхний элемент стека, не удаляя его (так
что промежуточные вычисления могут быть проверены).
    Сами операции помещения чисел в стек и их извлечения
очень просты, но, в связи с включением в настоящую программу
обнаружения ошибок и восстановления, они оказываются доста-
точно длинными. Поэтому лучше оформить их в виде отдельных
функций, чем повторять соответствующий текст повсюду в прог-
рамме. Кроме того, нужна отдельная функция для выборки из
ввода следующей операции или операнда. Таким образом, струк-
тура программы имеет вид:

while( поступает операция или операнд, а не конец
   if ( число )
        поместить его в стек
   еlse if ( операция )
        вынуть операнды из стека
        выполнить операцию
        поместить результат в стек
   else
        ошибка

    Основной вопрос, который еще не был обсужден, заключает-
ся в том, где поместить стек, т. е. какие процедуры смогут
обращаться к нему непосредственно. Одна из таких возможнос-
тей состоит в помещении стека в main и передачи самого стека
и текущей позиции в стеке функциям, работающим со стеком. Но
функции main нет необходимости иметь дело с переменными, уп-
равляющими стеком; ей естественно рассуждать в терминах по-
мещения чисел в стек и извлечения их оттуда. В силу этого мы
решили сделать стек и связанную с ним информацию внешними
переменными, доступными функциям push (помещение в стек) и
pop (извлечение из стека), но не main.
    Перевод этой схемы в программу достаточно прост. Ведущая
программа является по существу большим переключателем по ти-
пу операции или операнду; это, по-видимому, более характер-
ное применение переключателя, чем то, которое было продемонс-
трировано в главе 3.

   #define MAXOP   20  /* max size of operand, operаtor */
   #define NUMBER '0'  /* signal that number found */
   #define TOOBIG '9'  /* signal that string is too big *

   main()  /* reverse polish desk calculator */
   {
    int tupe;
    char s[MAXOP];
    double op2,atof(),pop(),push();

    while ((tupe=getop(s,MAXOP)) !=EOF);
      switch(tupe) {
      case NUMBER:
           push(atof(s));
           break;
      case '+':
           push(pop()+pop());
           break;
      case '*':
           push(pop()*pop());
           break;
      case '-':
           op2=pop();
           push(pop()-op2);
           break;
      case '/':
           op2=pop();
           if (op2 != 0.0)
             push(pop()/op2);
           else
              printf("zero divisor popped\n");
           break;
      case '=':
           printf("\t%f\n",push(pop()));
           break;
      case 'c':
           clear();
           break;
      case TOOBIG:
           printf("%.20s ... is too long\n",s)
           break;
      }
   }

   #define MAXVAL 100 /* maximum depth of val stack */
   int sp = 0;        /* stack pointer */
   double val[MAXVAL]; /*value stack */

   double push(f)    /* push f onto value stack */
   double f;
   {
    if (sp &lt; MAXVAL)
            return(val[sp++] = f);
    else    {
            printf("error: stack full\n");
            clear();
            return(0);
    }
   }

   double pop()   /* pop top value from stack */
   {
    if (sp > 0)
            return(val[--sp]);
    else    {
            printf("error: stack empty\n");
            clear();
            return(0);
    }
   }

   clear()       /* clear stack */
   {
     sp=0;
   }

    Команда C очищает стек с помощью функции clear, которая
также используется в случае ошибки функциями push и pop. К
функции getop мы очень скоро вернемся.
    Как уже говорилось в главе 1, переменная является внеш-
ней, если она определена вне тела какой бы то ни было функ-
ции. Поэтому стек и указатель стека, которые должны исполь-
зоваться функциями push, pop и clear, определены вне этих
трех функций. Но сама функция main не ссылается ни к стеку,
ни к указателю стека - их участие тщательно замаскировано. В
силу этого часть программы, соответствующая операции = , ис-
пользует конструкцию

   push(pop());

для того, чтобы проанализировать верхний элемент стека, не
изменяя его.
    Отметим также, что так как операции + и * коммутативны,
порядок, в котором объединяются извлеченные операнды, несу-
щественен, но в случае операций - и / необходимо различать
левый и правый операнды.

Упражнение 4-3
    Приведенная основная схема допускает непосредственное
расширение возможностей калькулятора. Включите операцию де-
ления по модулю (%) и унарный минус. Включите команду "сте-
реть", которая удаляет верхний элемент стека. Введите коман-
ды для работы с переменными. (Это просто, если имена пере-
менных будут состоять из одной буквы из имеющихся двадцати
шести букв).</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
