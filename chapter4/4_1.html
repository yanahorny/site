<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.1 Основные сведения</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	
<p>Для начала давайте разработаем и составим программу печати каждой строки ввода, которая содержит определенную комбинацию символов. (Это - специальный случай утилиты grep системы UNIX). Например, при поиске комбинации "the" в наборе строк</p>

<blockquote><pre>now is the time
for all good
men to come to the aid
of their party</pre></blockquote>

<p>в качестве выхода получим</p>

<blockquote><pre>now is the time
men to come to the aid
of their party</pre></blockquote>

<p>основная схема выполнения задания четко разделяется на три части:</p>

<blockquote><pre>while (имеется еще строка)
if (строка содержит нужную комбинацию)
  вывод этой строки</pre></blockquote>

<p>Конечно, возможно запрограммировать все действия в виде одной основной процедуры, но лучше использовать естественную структуру задачи и представить каждую часть в виде отдельной функции. С тремя маленькими кусками легче иметь дело, чем с одним большим, потому что отдельные не относящиеся к существу дела детали можно включить в функции и уменьшить возможность нежелательных взаимодействий. Кроме того, эти куски могут оказаться полезными сами по себе.</p>
<p>"Пока имеется еще строка" - это getline, функция, которую мы запрограммировали в главе 1, а "вывод этой строки" - это функция printf, которую уже кто-то подготовил для нас. Это значит, что нам осталось только написать процедуру для определения, содержит ли строка данную комбинацию символов или нет. Мы можем решить эту проблему, позаимствовав разработку из PL/1: функция index(s,t) возвращает позицию, или индекс, строки s, где начинается строка t, и -1, если s не содержит 
t . В качестве начальной позиции мы используем 0, а не 1, потому что в языке C массивы начинаются с позиции нуль. Когда нам в дальнейшем понадобится проверять на совпадение более сложные конструкции, нам придется заменить только функцию index; остальная часть программы останется той же самой.</p>
<p>После того, как мы потратили столько усилий на разработку, написание программы в деталях не представляет затруднений. Ниже приводится целиком вся программа, так что вы можете видеть, как соединяются вместе отдельные части. Комбинация символов, по которой производится поиск, выступает пока в качестве символьной строки в аргументе функции index, что не является самым общим механизмом. Мы скоро вернемся к обсуждению вопроса об инициализации символьных массивов и в главе 5 покажем, как сделать комбинацию символов параметром, которому присваивается значение в ходе выполнения программы. Программа также содержит новый вариант функции getline; вам может оказаться полезным сравнить его с вариантом из главы 1.</p>

<blockquote><pre>#define  MAXLINE  1000

 main()  /* find all lines matching a pattern */
 {
   char line[MAXLINE];
   while (getline(line, MAXLINE) > 0)
   if (index(line, "the") >= 0)
     printf("%s", line);
 }

 getline(s, lim) /* get line into s, return length *
 char s[];
 int lim;
 {
   int c, i;
   i = 0;
   while(--lim>0 &amp;&amp; (c=getchar()) != eof &amp;&amp; c != '\n')
     s[i++] = c;
   if (c == '\n')
     s[i++] = c;
   s[i] = '\0';
   return(i);
 }

 index(s,t) /* return index of t in s,-1 if none */
 char s[], t[];
 {
   int i, j, k;
   for (i = 0; s[i] != '\0'; i++) {
     for(j=i, k=0; t[k] !='\0' &amp;&amp; s[j] == t[k]; j++; k++)
     ;
     if (t[k] == '\0')
       return(i);
   }
   return(-1);
 }</pre></blockquote>

<p>Каждая функция имеет вид:</p>

<blockquote><pre>имя (список аргументов, если они имеются)
описания аргументов, если они имеются
{
  описания и операторы , если они имеются
}</pre></blockquote>

<p>Как и указывается, некоторые части могут отсутствовать; минимальной функцией является</p>

<blockquote><pre>dummy () { }</pre></blockquote>

<p>которая не совершает никаких действий.</p>

<pre>      (Такая ничего не делающая функция иногда оказывается
удобной для сохранения места для дальнейшего развития прог-
раммы). Если функция возвращает что-либо отличное от целого
значения, то перед ее именем может стоять указатель типа;
этот вопрос обсуждается в следующем разделе.
      Программой является просто набор определений отдельных
функций. Связь между функциями осуществляется через аргумен-
ты и возвращаемые функциями значения (в этом случае); ее
можно также осуществлять через внешние переменные. Функции
могут располагаться в исходном файле в любом порядке, а сама
исходная программа может размещаться на нескольких файлах,
но так, чтобы ни одна функция не расщеплялась.
      Оператор return служит механизмом для возвращения зна-
чения из вызванной функции в функцию, которая к ней обрати-
лась. За return может следовать любое выражение:

   return (выражение)

      Вызывающая функция может игнорировать возвращаемое
значение, если она этого пожелает. Более того, после return
может не быть вообще никакого выражения; в этом случае в вы-
зывающую программу не передается никакого значения. Управле-
ние также возвращется в вызывающую программу без передачи
какого-либо значения и в том случае, когда при выполнении мы
"проваливаемся" на конец функции, достигая закрывающейся
правой фигурной скобки. Eсли функция возвращает значение из
одного места и не возвращает никакого значения из другого
места, это не является незаконным, но может быть признаком
каких-то неприятностей. В любом случае "значением" функции,
которая не возвращает значения, несомненно будет мусор. От-
ладочная программа LINT проверяет такие ошибки.
      Механика компиляции и загрузки C-программ, располо-
женных в нескольких исходных файлах, меняется от системы к
системе. В системе UNIX, например, эту работу выполняет
команда 'cc', упомянутая в главе 1. Предположим, что три
функции находятся в трех различных файлах с именами main.с,
getline.c и index.с . Тогда команда

cc main.c getline.c index.c

компилирует эти три файла, помещает полученный настраиваемый
объектный код в файлы main.o, getline.o и index.o и загружа-
ет их всех в выполняемый файл, называемый a.out.
    Если имеется какая-то ошибка, скажем в main.c, то этот
файл можно перекомпилировать отдельно и загрузить вместе с
предыдущими объектными файлами по команде

cc main.c getline.o index.o

    Команда 'cc' использует соглашение о наименовании с ".с"
и ".о" для того, чтобы отличить исходные файлы от объектных.

Упражнение  4-1
    Составьте программу для функции rindex(s,t), которая
возвращает позицию самого правого вхождения t в s и -1, если
s не содержит t.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
