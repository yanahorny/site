<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.9 Инициализация</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Мы до сих пор уже много раз упоминали инициализацию, но
всегда мимоходом, среди других вопросов. Теперь, после того
как мы обсудили различные классы памяти, мы в этом разделе
просуммируем некоторые правила, относящиеся к инициализации.
    Если явная инициализация отсутствует, то внешним и ста-
тическим переменным присваивается значение нуль; автомати-
ческие и регистровые переменные имеют в этом случае неопре-
деленные значения (мусор).
    Простые переменные (не массивы или структуры) можно ини-
циализировать при их описании, добавляя вслед за именем знак
равенства и константное выражение:

 int x = 1;
 char squote = '\'';
 long day = 60 * 24;    /* minutes in a day */

Для внешних и статических переменных инициализация выполня-
ется только один раз, на этапе компиляции. Автоматические и
регистровые переменные инициализируются каждый раз при входе
в функцию или блок.
В случае автоматических и регистровых переменных инициализа-
тор не обязан быть константой: на самом деле он может быть
любым значимым выражением, которое может включать определен-
ные ранее величины и даже обращения к функциям. Например,
инициализация в программе бинарного поиска из главы 3 могла
бы быть записана в виде

 binary(x, v, n)
 int x, v[], n;
 {
    int low = 0;
    int high = n - 1;
    int mid;
    ...
 }

вместо

 binary(x, v, n)
 int x, v[], n;
 {
    int low, high, mid;

    low = 0;
   high = n - 1;
   ...
}

По своему результату, инициализации автоматических перемен-
ных являются сокращенной записью операторов присваивания.
Какую форму предпочесть - в основном дело вкуса. Мы обычно
используем явные присваивания, потому что инициализация в
описаниях менее заметна.
Автоматические массивы не могут быть инициализированы. Внеш-
ние и статические массивы можно инициализировать, помещая
вслед за описанием заключенный в фигурные скобки список на-
чальных значений, разделенных запятыми. Например программа
подсчета символов из главы 1, которая начиналась с

main()     /* count digits, white space, others */
 {
  int c, i, nwhite, nother;
  int ndigit[10];

  nwhite = nother = 0;
  for (i = 0; i &lt; 10; i++)
     ndigit[i] = 0;
  ...
 }

может быть переписана в виде

 int nwhite = 0;
 int nother = 0;
 int ndigit[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

 main()     /* count digits, white space, others */
  {
   int c, i;
   ...
  }

Эти инициализации фактически не нужны, так как все присваи-
ваемые значения равны нулю, но хороший стиль - сделать их
явными. Если количество начальных значений меньше, чем ука-
занный размер массива, то остальные элементы заполняются ну-
лями. Перечисление слишком большого числа начальных значений
является ошибкой. К сожалению, не предусмотрена возможность
указания, что некоторое начальное значение повторяется, и
нельзя инициализировать элемент в середине массива без пере-
числения всех предыдущих.
    Для символьных массивов существует специальный способ
инициализации; вместо фигурных скобок и запятых можно ис-
пользовать строку:

 char pattern[] = "the";

Это сокращение более длинной, но эквивалентной записи:

 char pattern[] = { 't', 'h', 'e', '\0' };

Если размер массива любого типа опущен, то компилятор опре-
деляет его длину, подсчитывая число начальных значений. В
этом конкретном случае размер равен четырем (три символа
плюс конечное \0).
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
