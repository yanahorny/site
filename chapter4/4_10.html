<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.10 Рекурсия</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    В языке C функции могут использоваться рекурсивно; это
означает, что функция может прямо или косвенно обращаться к
себе самой. Традиционным примером является печать числа в
виде строки символов. Как мы уже ранее отмечали, цифры гене-
рируются не в том порядке: цифры младших разрядов появляются
раньше цифр из старших разрядов, но печататься они должны в
обратном порядке.
    Эту проблему можно решить двумя способами. Первый спо-
соб, которым мы воспользовались в главе 3 в функции itoa,
заключается в запоминании цифр в некотором массиве по мере
их поступления и последующем их печатании в обратном поряд-
ке. Первый вариант функции printd следует этой схеме.

  printd(n)    /* print n in decimal */
  int n;
  {
    char s[10];
    int i;

    if (n &lt; 0) {
       putchar('-');
       n = -n;
    }
    i = 0;
    do {
       s[i++] = n % 10 + '0'; /* get next char */
    } while ((n /= 10) > 0); /* discard it */
    while (--i >= 0)
       putchar(s[i]);
  }

    Альтернативой этому способу является рекурсивное реше-
ние, когда при каждом вызове функция printd сначала снова
обращается к себе, чтобы скопировать лидирующие цифры, а за-
тем печатает последнюю цифру.

 printd(n)   /* print n in decimal (recursive)*/
 int n;
  {
   int i;

   if (n &lt; 0) {
      putchar('-');
      n = -n;
   }
   if ((i = n/10) != 0)
      printd(i);
   putchar(n % 10 + '0');
  }

    Когда функция вызывает себя рекурсивно, при каждом обра-
щении образуется новый набор всех автоматических переменных,
совершенно не зависящий от предыдущего набора. Таким обра-
зом, в printd(123) первая функция printd имеет n = 123. Она
передает 12 второй printd, а когда та возвращает управление
ей, печатает 3. Точно так же вторая printd передает 1
третьей (которая эту единицу печатает), а затем печатает 2.
    Рекурсия обычно не дает никакой экономии памяти, пос-
кольку приходится где-то создавать стек для обрабатываемых
значений. Не приводит она и к созданию более быстрых прог-
рамм. Но рекурсивные программы более компактны, и они зачас-
тую становятся более легкими для понимания и написания. Ре-
курсия особенно удобна при работе с рекурсивно определяемыми
структурами данных, например, с деревьями; хороший пример
будет приведен в главе 6.

Упражнение 4-7
    Приспособьте идеи, использованные в printd для рекурсив-
ного  написания itoa; т.е. преобразуйте целое в строку с по-
мощью рекурсивной процедуры.

Упражнение 4-8
    Напишите рекурсивный вариант функции reverse(s), которая
располагает в обратном порядке строку s.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
