<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>4.5.1 Область действия</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Областью действия имени является та часть программы, в
которой это имя определено. Для автоматической переменной,
описанной в начале функции, областью действия является та
функция, в которой описано имя этой переменной, а переменные
из разных функций, имеющие одинаковое имя, считаются не от-
носящимися друг к другу. Это же справедливо и для аргументов
функций.
    Область действия внешней переменной простирается от точ-
ки, в которой она объявлена в исходном файле, до конца этого
файла. Например, если val, sp, push, pop и clear определены
в одном файле в порядке, указанном выше, а именно:

     int  sp = 0;
     double  val[MAXVAL];

     double  push(f) {...}

     double  pop()  {...}

     clear()  {...}

то переменные val и sp можно использовать в push, pop и
clear прямо по имени; никакие дополнительные описания не
нужны.
    С другой стороны, если нужно сослаться на внешнюю пере-
менную до ее определения, или если такая переменная опреде-
лена в файле, отличном от того, в котором она используется,
то необходимо описание extern.
    Важно различать описание внешней переменной и ее опреде-
ление. Описание указывает свойства переменной (ее тип, раз-
мер и т.д.); определение же вызывает еще и отведение памяти.
Если вне какой бы то ни было функции появляются строчки

   int  sp;
   double  val[MAXVAL];

то они определяют внешние переменные sp и val, вызывают от-
ведение памяти для них и служат в качестве описания для ос-
тальной части этого исходного файла. В то же время строчки

   extern  int  sp;
   extern  double  val[];

описывают в остальной части этого исходного файла переменную
sp как int, а val как массив типа double (размер которого
указан в другом месте), но не создают переменных и не отво-
дят им места в памяти.
    Во всех файлах, составляющих исходную программу, должно
содержаться только одно определение внешней переменной; дру-
гие файлы могут содержать описания extern для доступа к ней.
(Описание extern может иметься и в том файле, где находится
определение). Любая инициализация внешней переменной прово-
дится только в определении. В определении должны указываться
размеры массивов, а в описании extern этого можно не делать.
    Хотя подобная организация приведенной выше программы и
маловероятна, но val и sp могли бы быть определены и инициа-
лизированы в одном файле, а функция push, pop и clear опре-
делены в другом. В этом случае для связи были бы необходимы
следующие определения и описания:

в файле 1:

   int sp = 0;  /* stack pointer */
   double val[MAXVAL]; /* value stack */

в файле 2:

    extern int sp;
    extern double val[];

    double push(f)  {...}

    double pop()   {...}

    clear()   {...}

так как описания extern 'в файле 1' находятся выше и вне
трех указанных функций, они относятся ко всем ним; одного
набора описаний достаточно для всего 'файла 2'.
    Для программ большого размера обсуждаемая позже в этой
главе возможность включения файлов, #include, позволяет
иметь во всей программе только одну копию описаний extern и
вставлять ее в каждый исходный файл во время его компиляции.
    Обратимся теперь к функции getop, выбирающей из файла
ввода следующую операцию или операнд. Основная задача прос-
та: пропустить пробелы, знаки табуляции и новые строки. Если
следующий символ отличен от цифры и десятичной точки, то
возвратить его. В противном случае собрать строку цифр (она
может включать десятичную точку) и возвратить NUMBER как
сигнал о том, что выбрано число.
    Процедура существенно усложняется, если стремиться пра-
вильно обрабатывать ситуацию, когда вводимое число оказыва-
ется слишком длинным. Функция getop считывает цифры подряд
(возможно с десятичной точкой) и запоминает их, пока после-
довательность не прерывается. Если при этом не происходит
переполнения, то функция возвращает NUMBER и строку цифр.
Если же число оказывается слишком длинным, то GETOP отбрасы-
вает остальную часть строки из файла ввода, так что пользо-
ватель может просто перепечатать эту строку с места ошибки;
функция возвращает TOOBIG как сигнал о переполнении.

 getop(s, lim) /* get next oprerator or operand */
 char s[];
 int lim;
 {
   int i, c;
   while((c=getch())==' '|| c=='\t' || c=='\n')
    ;
   if (c != '.' &amp;&amp; (c &lt; '0' || c > '9'))
     return(c);
   s[0] = c;
   for(i=1; (c=getchar()) >='0' &amp;&amp; c &lt;= '9'; i++)
     if (i &lt; lim)
       s[i] = c;
   if (c == '.') {   /* collect fraction */
     if (i &lt; lim)
       s[i] = c;
     for(i++;(c=getchar()) >='0' &amp;&amp; c&lt;='9';i++)
       if (i &lt; lim)
         s[i] =c;
   }
   if (i &lt; lim)  { /* number is ok */
     ungetch(c);
     s[i] = '\0';
     return (NUMBER);

   } else { /* it's too big; skip rest of line */
     while (c != '\n' &amp;&amp; c != eof)
            c = getchar();
     s[lim-1] = '\0';
     return (TOOBIG);
   }
 }

    Что же представляют из себя функции 'getch' и 'ungetch'?
Часто так бывает, что программа, считывающая входные данные,
не может определить, что она прочла уже достаточно, пока она
не прочтет слишком много. Одним из примеров является выбор
символов, составляющих число: пока не появится символ, от-
личный от цифры, число не закончено. Но при этом программа
считывает один лишний символ, символ, для которого она еще
не подготовлена.
    Эта проблема была бы решена, если бы было бы возможно
"прочесть обратно" нежелательный символ. Тогда каждый раз,
прочитав лишний символ, программа могла бы поместить его об-
ратно в файл ввода таким образом, что остальная часть прог-
раммы могла бы вести себя так, словно этот символ никогда не
считывался. К счастью, такое неполучение символа легко имми-
тировать, написав пару действующих совместно функций. Функ-
ция getch доставляет следующий символ ввода, подлежащий рас-
смотрению; функция ungetch помещает символ назад во ввод,
так что при следующем обращении к getch он будет возвращен.
    То, как эти функции совместно работают, весьма просто.
Функция ungetch помещает возвращаемые назад символы в сов-
местно используемый буфер, являющийся символьным массивом.
Функция getch читает из этого буфера, если в нем что-либо
имеется; если же буфер пуст, она обращается к getchar. При
этом также нужна индексирующая переменная, которая будет
фиксировать позицию текущего символа в буфере.
    Так как буфер и его индекс совместно используются функ-
циями getch и ungetch и должны сохранять свои значения в пе-
риод между обращениями, они должны быть внешними для обеих
функций. Таким образом, мы можем написать getch, ungetch и
эти переменные как:

 #define  BUFSIZE  100
 char buf[BUFSIZE]; /* buffer for ungetch */
 int bufp = 0; /* next free position in buf */

 getch() /* get a (possibly pushed back) character */
 {
   return((bufp > 0) ? buf[--bufp] : getchar());
 }

 ungetch(c)  /* push character back on input */
 int c;
 {
   if (bufp > BUFSIZE)
     printf("ungetch: too many characters\n");
   else
     buf [bufp++] = c;
 }

Мы использовали для хранения возвращаемых символов массив, а
не отдельный символ, потому что такая общность может приго-
диться в дальнейшем.

Упражнение  4-4
Напишите функцию ungets(s) , которая будет возвращать во
ввод целую строку. Должна ли ungets иметь дело с buf и bufp
или она может просто использовать ungetch ?

Упражнение  4-5
Предположите, что может возвращаться только один символ. Из-
мените getch и ungetch соответствующим образом.

Упражнение  4-6
Наши функции getch и ungetch не обеспечивают обработку возв-
ращенного символа EOF переносимым образом. Решите, каким
свойством должны обладать эти функции, если возвращается
EOF, и реализуйте ваши выводы.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
