<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>3.6 Цикл do - while</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
		<p>Как уже отмечалось в главе 1, циклы while и for обладают тем приятным свойством, что в них проверка окончания осуществляется в начале, а не в конце цикла. Третий оператор цикла языка C, do-while, проверяет условие окончания в конце, после каждого прохода через тело цикла; тело цикла всегда выполняется, по крайней мере, один раз. Синтаксис этого оператора имеет вид:</p>
		<blockquote><pre>do
  оператор
while (выражение)</pre></blockquote>
		<p>Сначала выполняется оператор, затем вычисляется выражение. Если оно истинно, то оператор выполняется снова и т.д. Если выражение становится ложным, цикл заканчивается.</p>
		<p>Как и можно было ожидать, цикл do-while используется значительно реже, чем while и for, составляя примерно пять процентов от всех циклов. Тем не менее, иногда он оказывается полезным, как, например, в следующей функции itoa, которая преобразует число в символьную строку (обратная функции atoi). Эта задача оказывается несколько более сложной, чем может показаться сначала. Дело в том, что простые методы выделения цифр генерируют их в неправильном порядке. Мы предпочли получить строку в обратном порядке, а затем обратить ее.</p>

<blockquote><pre class="cpp">itoa(n,s)   /*convert n to characters in s */
char s[];
int n;
{
  int i, sign;
  if ((sign = n) &lt; 0)   /* record sign */
    n = -n;     /* make n positive */
  i = 0;
  do {    /* generate digits in reverse order */
    s[i++] = n % 10 + '0'; /* get next digit */
  } while ((n /=10) > 0);  /* delete it */
  if (sign &lt; 0)
    s[i++] = '-'
  s[i] = '\0';
  reverse(s);
}</pre></blockquote>
		<p>Цикл do-while здесь необходим, или по крайней мере удобен, поскольку, каково бы ни было значение n, массив s должен содержать хотя бы один символ. Мы заключили в фигурные скобки один оператор, составляющий тело do-whilе, хотя это и не обязательно, для того, чтобы торопливый читатель не принял часть while за начало оператора цикла while.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 3-3</span></p>
			<p>При представлении чисел в двоичном дополнительном коде наш вариант itoa не справляется с наибольшим отрицательным числом, т.е. со значением n равным -2 в степени m-1, где m - размер слова. Объясните почему. Измените программу так, чтобы она правильно печатала это значение на любой машине.</p>
			<p><span class="exercisetitle">Упражнение 3-4</span></p>
			<p>Напишите аналогичную функцию itob(n,s), которая преобразует целое без знака n в его двоичное символьное представление в s. Запрограммируйте функцию itoh, которая преобразует целое в шестнадцатеричное представление.</p>
			<p><span class="exercisetitle">Упражнение 3-5</span></p>
			<p>Напишите вариант itoa, который имеет три, а не два аргумента. Третий аргумент - минимальная ширина поля; преобразованное число должно, если это необходимо, дополняться слева пробелами, так чтобы оно имело достаточную ширину.</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>