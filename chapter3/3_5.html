<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>3.5 Циклы - while и for</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>Мы уже сталкивались с операторами цикла while и for. В конструкции</p>

<blockquote><pre>while (выражение)
  оператор</pre></blockquote>

<p>вычисляется выражение. Если его значение отлично от нуля, то выполняется оператор и выражение вычисляется снова. Этот цикл продолжается до тех пор, пока значение выражения не станет нулем, после чего выполнение программы продолжается с места после оператора.</p>

<p>Оператор</p>

<blockquote><pre>for (выражение 1; выражение 2; выражение 3)
  оператор</pre></blockquote>

<p>эквивалентен последовательности</p>

<blockquote><pre>выражение 1;
while (выражение 2) {
  оператор
  выражение 3;
}</pre></blockquote>

<p>Грамматически все три компонента в for являются выражениями. Наиболее распространенным является случай, когда выражение 1 и выражение 3 являются присваиваниями или обращениями к функциям, а выражение 2 - условным выражением. Любая из трех частей может быть опущена, хотя точки с запятой при этом должны оставаться. Если отсутствует выражение 1 или выражение 3, то оно просто выпадает из расширения. Если же отсутствует проверка, выражение 2, то считается, как будто оно всегда истинно, так что</p>

<blockquote><pre>for (;;) {
  ...
}</pre></blockquote>

<p>является бесконечным циклом, о котором предполагается, что он будет прерван другими средствами (такими как break или return).</p>
<p>Использовать ли while или for - это, в основном дело вкуса. Например, в</p>

<blockquote><pre>while ((c = getchar()) == ' ' || c == '\n' || c == '\t')
;    /* skip white space characters */</pre></blockquote>

<p>нет ни инициализации, ни реинициализации, так что цикл while выглядит самым естественным.</p>
<p>Цикл for, очевидно, предпочтительнее там, где имеется простая инициализация и реинициализация, поскольку при этом управляющие циклом операторы наглядным образом оказываются вместе в начале цикла. Это наиболее очевидно в конструкции</p>

<blockquote><pre>for (i = 0; i &lt; n; i++)</pre></blockquote>

<p>которая является идиомой языка C для обработки первых n элементов массива, аналогичной оператору цикла do в Фортране и PL/1. Аналогия, однако, не полная, так как границы цикла могут быть изменены внутри цикла, а управляющая переменная сохраняет свое значение после выхода из цикла, какова бы ни была причина этого выхода. Поскольку компонентами for могут быть произвольные выражения, они не ограничиваются только арифметическими прогрессиями. Тем не менее, является плохим стилем включать в for вычисления, которые не относятся к управлению циклом, лучше поместить их в управляемые циклом операторы.</p>
<p>В качестве большего по размеру примера приведем другой вариант функции atoi, преобразующей строку в ее численный эквивалент. Этот вариант является более общим; он допускает присутствие в начале символов пустых промежутков и знака + или -. (В главе 4 приведена функция atof, которая выполняет то же самое преобразование для чисел с плавающей точкой).</p>
		<p>Общая схема программы отражает форму поступающих данных:</p>
		<ul>
			<li>пропустить пустой промежуток, если он имеется
			<li>извлечь знак, если он имеется 
			<li>извлечь целую часть и преобразовать ее
		</ul>
		<p>Каждый шаг выполняет свою часть работы и оставляет все в подготовленном состоянии для следующей части. Весь процесс заканчивается на первом символе, который не может быть частью числа.</p>
		<blockquote><pre class="cpp">atoi(s)   /* convert s to integer */
char s[];
{
  int i, n, sign;
  for(i=0;s[i]==' ' || s[i]=='\n' || s[i]=='\t';i++)
  ; /* skip white space */
  sign = 1;
  if(s[i] == '+' || s[i] == '-')  /* sign */
    sign = (s[i++]=='+') ? 1 : - 1;
  for( n = 0; s[i] >= '0' &amp;&amp; s[i] &lt;= '9'; i++)
    n = 10 * n + s[i] - '0';
  return(sign * n);
}</pre></blockquote>

<p>Преимущества централизации управления циклом становятся еще более очевидными, когда имеется несколько вложенных циклов. Следующая функция сортирует массив целых чисел по методу Шелла. Основная идея сортировки по Шеллу заключается в том, что сначала сравниваются удаленные элементы, а не смежные, как в обычном методе сортировки. Это приводит к быстрому устранению большой части неупорядоченности и сокращает последующую работу. Интервал между элементами постепенно сокращается до единицы, когда сортировка фактически превращается в метод перестановки соседних элементов.</p>

<blockquote><pre class="cpp">shell(v, n)   /* sort v[0]...v[n-1] into increasing order */
int v[], n;
{
  int gap, i, j, temp;
  for (gap = n/2; gap > 0; gap /= 2)
    for (i = gap; i &lt; n; i++)
      for (j=i-gap; j>=0 &amp;&amp; v[j]>v[j+gap]; j-=gap) {
        temp = v[j];
        v[j] = v[j+gap];
        v[j+gap] = temp;
      }
}</pre></blockquote>

<p>Здесь имеются три вложенных цикла. Самый внешний цикл управляет интервалом между сравниваемыми элементами, уменьшая его от n/2 вдвое при каждом проходе, пока он не станет равным нулю. Средний цикл сравнивает каждую пару элементов, разделенных на величину интервала; самый внутренний цикл переставляет любую неупорядоченную пару. Так как интервал в конце концов сводится к единице, все элементы в результате упорядочиваются правильно. Отметим, что в силу общности конструкции for внешний цикл укладывается в ту же самую форму, что и остальные, хотя он и не является арифметической прогрессией.</p>
<p>Последней операцией языка C является запятая ",", которая чаще всего используется в операторе for. Два выражения, разделенные запятой, вычисляются слева направо, причем типом и значением результата являются тип и значение правого операнда. Таким образом, в различные части оператора for можно включить несколько выражений, например, для параллельного изменения двух индексов. Это иллюстрируется функцией reverse(s), которая располагает строку s в обратном порядке на том же месте.</p>

<blockquote><pre class="cpp">reverse(s)    /* reverse string s in place */
char s[];
{
  int c, i, j;
  for(i = 0, j = strlen(s) - 1; i &lt; j; i++, j--) {
    c = s[i];
    s[i] = s[j];
    s[j] = c;
  }
}</pre></blockquote>
		<p>Запятые, которые разделяют аргументы функций, переменные в описаниях и т.д., не имеют отношения к операции запятая и не обеспечивают вычислений слева направо.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 3-2</span></p>
			<p>Составьте программу для функции expand(s1,s2), которая расширяет сокращенные обозначения вида а-Z из строки s1 в эквивалентный полный список авс...XYZ в s2. Допускаются сокращения для строчных и прописных букв и цифр. Будьте готовы иметь дело со случаями типа а-в-с, а-Z0-9 и -а-Z. (Полезное соглашение состоит в том, что символ -, стоящий в начале или конце, воспринимается буквально).</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>