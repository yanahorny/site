<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
		<title>1.5.2 Копирование файла</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>Имея в своем распоряжении только функции getchar и putchar вы можете, не зная ничего более об операциях ввода-вывода, написать удивительное количество полезных программ. Простейшим примером может служить программа посимвольного копирования входного файла в выходной. Общая схема имеет вид:</p>

<blockquote><pre>ввести символ
while (символ не является признаком конца файла)
  вывести только что прочитанный символ
  ввести новый символ</pre></blockquote>
		<p>программа, написанная на языке C, выглядит следующим образом:</p>
		<blockquote>
			<pre class="cpp">main()  /* copy input to output; 1st version */
{
  int c;
  c = getchar();
  while (c != EOF) {
    putchar (c);
    c = getchar();
  }
}
</pre>
		</blockquote>
		<p>оператор отношения != означает "не равно".</p>
		<p>Основная проблема заключается в том, чтобы зафиксировать конец файла ввода. Обычно, когда функция getchar наталкивается на конец файла ввода, она возвращает значение, не являющееся действительным символом; таким образом, программа может установить, что файл ввода исчерпан. Единственное осложнение, являющееся значительным неудобством, заключается в существовании двух общеупотребительных соглашений о том, какое значение фактически является признаком конца файла. Мы отсрочим решение этого вопроса, использовав символическое имя EOF для этого значения, каким бы оно ни было. На практике EOF будет либо -1, либо 0, так что для правильной работы перед программой должно стоять собственно либо</p>
		<blockquote>
			<pre>#define EOF -1</pre>
		</blockquote>
		<p>либо</p>
		<blockquote>
			<pre>#define EOF 0</pre>
		</blockquote>
		<p>Использовав символическую константу EOF для представления значения, возвращаемого функцией getchar при выходе на конец файла, мы обеспечили, что только одна величина в программе зависит от конкретного численного значения.</p>
		<p>Мы также описали переменную <code>c</code> как int, а не char, с тем, чтобы она могла хранить значение, возвращаемое getchar. Как мы увидим в главе 2, эта величина действительно int, так как она должна быть в состоянии в дополнение ко всем возможным символам представлять и EOF.</p>
		<p>Программистом, имеющим опыт работы на C, программа копирования была бы написана более сжато. В языке C любое присваивание, такое как</p>
		<blockquote>
			<pre>c = getchar()</pre>
		</blockquote>
		<p>может быть использовано в выражении; его значение - просто значение, присваиваемое левой части. Если присваивание символа переменной <code>c</code> поместить внутрь проверочной части оператора while, то программа копирования файла запишется в виде:</p>
		<blockquote>
			<pre class="cpp">main()  /* copy input to output; 2nd version */
{
  int c;
  while ((c = getchar()) != EOF)
    putchar(c);
}</pre>
		</blockquote>
		<p>Программа извлекает символ, присваивает его переменной <code>c</code> и затем проверяет, не является ли этот символ признаком конца файла. Если нет - выполняется тело оператора while, выводящее этот символ. Затем цикл while повторяется. Когда, наконец, будет достигнут конец файла ввода, оператор while завершается, а вместе с ним заканчивается выполнение и функции main.</p>
		<p>В этой версии централизуется ввод - в программе только одно обращение к функции getchar - и ужимается программа. Вложение присваивания в проверяемое условие - это одно из тех мест языка C, которое приводит к значительному сокращению программ. Однако, на этом пути можно увлечься и начать писать недоступные для понимания программы. Эту тенденцию мы будем пытаться сдерживать.</p>
		<p>Важно понять, что круглые скобки вокруг присваивания в условном выражении действительно необходимы. Старшинство операции != выше, чем операции присваивания =, а это означает, что в отсутствие круглых скобок проверка условия != будет выполнена до присваивания =. Таким образом, оператор</p>
		<blockquote>
			<pre>c = getchar() != EOF</pre>
		</blockquote>
		<p>эквивалентен оператору</p>
		<blockquote>
			<pre>c = (getchar() != EOF)</pre>
		</blockquote>
		<p>Это, вопреки нашему желанию, приведет к тому, что <code>c</code> будет принимать значение 0 или 1 в зависимости от того, натолкнется или нет getchar на признак конца файла. Подробнее об этом будет сказано в <a href="../chapter2/2.html">главе&nbsp;2</a>.</p>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>