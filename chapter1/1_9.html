<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>1.9 Массивы символов</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>По-видимому самым общим типом массива в C является массив символов. Чтобы проиллюстрировать использование массивов символов и обрабатывающих их функций, давайте напишем программу, которая читает набор строк и печатает самую длинную из них. Основная схема программы достаточно проста:</p>

<blockquote><pre>while (имеется еще строка)
  if (эта строка длиннее самой длинной из предыдущих)
    запомнить эту строку и ее длину
напечатать самую длинную строку</pre></blockquote>

<p>По этой схеме ясно, что программа естественным образом распадается на несколько частей. Одна часть читает новую строку, другая проверяет ее, третья запоминает, а остальные части программы управляют этим процессом.</p>
<p>Поскольку все так прекрасно делится, было бы хорошо и написать программу соответствующим образом. Давайте сначала напишем отдельную функцию getline, которая будет извлекать следующую строку из файла ввода; это - обобщение функции getchar. мы попытаемся сделать эту функцию по возможности более гибкой, чтобы она была полезной и в других ситуациях. Как минимум getline должна передавать сигнал о возможном появлении конца файла; более общий полезный вариант мог бы передавать длину строки или нуль, если встретится конец файла. Нуль не может быть длиной строки, так как каждая строка содержит по крайней мере один символ; даже строка, содержащая только символ новой строки, имеет длину 1.</p>
<p>Когда мы находим строку, которая длиннее самой длинной из предыдущих, то ее надо где-то запомнить. Это наводит на мысль о другой функции, copy, которая будет копировать новую строку в место хранения.</p>
		<p>Наконец, нам нужна основная программа для управления функциями getline и copy. Вот результат:</p>
		<blockquote>
			<pre class="cpp">#define MAXLINE 1000 /* maximum input line size */
main()  /* find longest line */
{
  int len; /* current line length */
  int max; /* maximum length seen so far */
  char line[MAXLINE]; /* current input line */
  char save[MAXLINE]; /* longest line, saved */
  max = 0;
  while ((len = getline(line, MAXLINE)) > 0)
    if (len > max) {
      max = len;
      copy(line, save);
    }
  if (max > 0)   /* there was a line */
    printf("%s", save);
}
getline(s,lim) /* get line into s,return length */
char s[];
int lim;
{
  int c, i;
  for(i=0; i&lt;lim-1 && (c=getchar())!=EOF && c!='\n'; ++i)
    s[i] = c;
  if (c == '\n')  {
    s[i] = c;
    ++i;
  }
  s[i] = '\0';
  return(i);
}

copy(s1, s2)    /* copy s1 to s2; assume s2 big enough */
char s1[], s2[];
{
  int i;
  i = 0;
  while ((s2[i] = s1[i] != '\0')
    ++i;
}
</pre>
		</blockquote>
		<p>Функция main и getline общаются как через пару аргументов, так и через возвращаемое значение. Аргументы getline описаны в строках</p>
		<blockquote>
			<pre>char s[];
int lim;</pre>
		</blockquote>
		<p>которые указывают, что первый аргумент является массивом, а второй - целым.</p>
		<p>Длина массива s не указана, так как она определена в main. Функция getline использует оператор return для передачи значения назад в вызывающую программу точно так же, как это делала функция power. Одни функции возвращают некоторое нужное значение; другие, подобно copy, используются из-за их действия и не возвращают никакого значения.</p>
<p>Чтобы пометить конец строки символов, функция getline помещает в конец создаваемого ей массива символ \0 (нулевой символ, значение которого равно нулю). Это соглашение используется также компилятором с языка C: когда в C - программе встречается строчная константа типа</p>

<blockquote>
			<pre>"hello\n"</pre>
		</blockquote>

<p>то компилятор создает массив символов, содержащий символы этой строки, и заканчивает его символом \0, с тем, чтобы функции, подобные printf, могли зафиксировать конец массива:</p>

<blockquote><table width="243" border="1" cellspacing="0" cellpadding="0" bordercolor="black">
			<tr align="center" valign="middle">
				<td width="14%">h</td>
				<td width="14%">e</td>
				<td width="14%">l</td>
				<td width="14%">l</td>
				<td width="14%">o</td>
				<td width="14%">\n</td>
				<td width="17%">\0</td>
			</tr>
		</table></blockquote>
<p>Спецификация формата %s указывает, что printf ожидает строку, представленную в такой форме. Проанализировав функцию copy, вы обнаружите, что и она опирается на тот факт, что ее входной аргумент оканчивается символом \0, и копирует этот символ в выходной аргумент s2. (Все это подразумевает, что символ \0 не является частью нормального текста).</p>
<p>Между прочим, стоит отметить, что даже в такой маленькой программе, как эта, возникает несколько неприятных организационных проблем. Например, что должна делать main, если она встретит строку, превышающую ее максимально возможный размер? Функция getline поступает разумно: при заполнении массива она прекращает дальнейшее извлечение символов, даже если не встречает символа новой строки. Проверив полученную длину и последний символ, функция main может установить, не была ли эта строка слишком длинной, и поступить затем, как она сочтет нужным. Ради краткости мы опустили эту проблему.</p>
		<p>Пользователь функции getline никак не может заранее узнать, насколько длинной окажется вводимая строка. Поэтому в getline включен контроль переполнения. В то же время пользователь функции copy уже знает (или может узнать), каков размер строк, так что мы предпочли не включать в эту функцию дополнительный контроль.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 1-14</span></p>
			<p>Переделайте ведущую часть программы поиска самой длинной строки таким образом, чтобы она правильно печатала длины сколь угодно длинных вводимых строк и возможно больший текст.</p>
			<p><span class="exercisetitle">Упражнение 1-15</span></p>
			<p>Напишите программу печати всех строк длиннее 80 символов.</p>
			<p><span class="exercisetitle">Упражнение 1-16</span></p>
			<p>Напишите программу, которая будет удалять из каждой строки стоящие в конце пробелы и табуляции, а также строки, целиком состоящие из пробелов.</p>
			<p><span class="exercisetitle">Упражнение 1-17</span></p>
			<p>Напишите функцию reverse(s), которая располагает символьную строку s в обратном порядке. С ее помощью напишите программу, которая обратит каждую строку из файла ввода.</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>