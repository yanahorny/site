<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>1.6 Массивы</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>Давайте напишем программу подсчета числа появлений каждой цифры, символов пустых промежутков (пробел, табуляции, новая строка) и всех остальных символов. Конечно, такая задача несколько искусственна, но она позволит нам проиллюстрировать в одной программе сразу несколько аспектов языка C.</p>
		<p>Мы разбили вводимые символы на двенадцать категорий, и нам удобнее использовать массив для хранения числа появлений каждой цифры, а не десять отдельных переменных. Вот один из вариантов программы:</p>
		<blockquote>
			<pre class="cpp">main()  /* count digits, white space, others */
{
  int c, i, nwhite, nother;
  int  ndigit[10];
  nwhite = nother = 0;
  for (i = 0; i &lt; 10; ++i)
    ndigit[i] = 0;
  while ((c = getchar()) != eof)
    if (c >= '0' && c &lt;= '9')
      ++ndigit[c-'0'];
    else if(c == ' ' || c == '\n' || c == '\t')
      ++nwhite;
    else
     ++nother;
  printf("digits =");
  for (i = 0; i &lt; 10; ++i)
  printf(" %d", ndigit[i]);
  printf("\nwhite space = %d, other = %d\n", nwhite, nother);
}</pre>
		</blockquote>
		<p>Описание</p>
		<blockquote>
			<pre>int ndigit[10];</pre>
		</blockquote>
		<p>объявляет, что ndigit является массивом из десяти целых. В языке C индексы массива всегда начинаются с нуля (а не с 1, как в Фортране или PL/1), так что элементами массива являются ndigit[0], ndigit[1],..., ndigit[9]. Эта особенность отражена в циклах for, которые инициализируют и печатают массив.</p>
		<p>Индекс может быть любым целым выражением, которое, конечно, может включать целые переменные, такие как i, и целые константы.</p>
		<p>Эта конкретная программа сильно опирается на свойства символьного представления цифр. Так, например, в программе проверка</p>
		<blockquote>
			<pre>if( c &gt;= '0' &amp;&amp; c &lt;= '9')...</pre>
		</blockquote>
		<p>определяет, является ли символ в c цифрой, и если это так, то численное значение этой цифры определяется по формуле c - '0'. Такой способ работает только в том случае, если значения символьных констант '0', '1' и т.д. положительны, расположены в порядке возрастания и нет ничего, кроме цифр, между константами '0' и '9'. К счастью, это верно для всех общепринятых наборов символов.</p>
		<p>По определению перед проведением арифметических операций, вовлекающих переменные типа char и int, все они преобразуются к типу int, так что в арифметических выражениях переменные типа char по существу идентичны переменным типа int. Это вполне естественно и удобно; например, c -'0'- это целое выражение со значением между 0 и 9 в соответствии с тем, какой символ от '0' до '9' хранится в c, и, следовательно, оно является подходящим индексом для массива ndigit.</p>
		<p>Выяснение вопроса, является ли данный символ цифрой, символом пустого промежутка или чем-либо еще, осуществляется последовательностью операторов</p>
		<blockquote>
			<pre>if (c >= '0' && c &lt;= '9')
  ++ndigit[c-'0'];
else if(c == ' ' || c == '\n' || c == '\t')
  ++nwhite;
else
  ++nother;</pre>
		</blockquote>
		<p>Конструкция</p>
		<blockquote><pre>if (условие)
  оператор
else if (условие)
  оператор
else
  оператор</pre></blockquote>

<p>часто встречаются в программах как средство выражения ситуаций, в которых осуществляется выбор одного из нескольких возможных решений.</p>
<p>Программа просто движется сверху вниз до тех пор, пока не удовлетворится какое-нибудь условие; тогда выполняется соответствующий "оператор", и вся конструкция завершается. (Конечно, "оператор" может состоять из нескольких операторов, заключенных в фигурные скобки). Если ни одно из условий не удовлетворяется, то выполняется "оператор", стоящий после заключительного else, если оно присутствует. Если последнее else и соответствующий "оператор" опущены (как в программе подсчета слов), то никаких действий не производится. Между начальным if и конечным else может помещаться произвольное количество групп</p>

<blockquote><pre>else if (условие)
  оператор</pre></blockquote>

<p>С точки зрения стиля целесообразно записывать эту конструкцию так, как мы показали, с тем чтобы длинные выражения не залезали за правый край страницы.</p>
		<p>Оператор switch (переключатель), который рассматривается в <a href="../chapter3/3.html">главе&nbsp;3</a>, представляет другую возможность для записи разветвления на несколько вариантов. Этот оператор особенно удобен, когда проверяемое выражение является либо просто некоторым целым, либо символьным выражением, совпадающим с одной из некоторого набора констант. Версия этой программы, использующая оператор switch, будет для сравнения приведена в <a href="../chapter3/3.html">главе&nbsp;3</a>.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение  1-12</span></p>
			<p>Напишите программу, печатающую гистограмму длин слов из файла ввода. Самое легкое - начертить гистограмму горизонтально; вертикальная ориентация требует больших усилий.</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
