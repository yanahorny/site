<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>1.10 Область действия: внешние переменные</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>Переменные в main (line, save и т.д.) являются внутренними или локальными по отношению к функции main, потому что они описаны внутри main и никакая другая функция не имеет к ним прямого доступа. Это же верно и относительно переменных в других функциях; например, переменная i в функции getline никак не связана с i в copy. Каждая локальная переменная существует только тогда, когда произошло обращение к соответствующей функции, и исчезает, как только закончится выполнение этой функции. По этой причине такие переменные, следуя терминологии других языков, обычно называют автоматическими. Мы впредь будем использовать термин автоматические при ссылке на эти динамические локальные переменные. (В <a href="../chapter4/4.html">главе&nbsp;4</a> обсуждается класс статической памяти, когда локальные переменные все же оказываются в состоянии сохранить свои значения между обращениями к функциям).</p>
<p>Поскольку автоматические переменные появляются и исчезают вместе с обращением к функции, они не сохраняют своих значений в промежутке от одного вызова до другого, в силу чего им при каждом входе нужно явно присваивать значения. Если этого не сделать, то они будут содержать мусор.</p>
<p>В качестве альтернативы к автоматическим переменным можно определить переменные, которые будут внешними для всех функций, т.е. глобальными переменными, к которым может обратиться по имени любая функция, которая пожелает это сделать (этот механизм весьма сходен с COMMON в Фортране и EXTERNAL в PL/1). Так как внешние переменные доступны всюду, их можно использовать вместо списка аргументов для передачи данных между функциями. Кроме того, поскольку внешние переменные существуют постоянно, а не появляются и исчезают вместе с вызываемыми функциями, они сохраняют свои значения и после того, как функции, присвоившие им эти значения, завершат свою работу.</p>
		<p>Внешняя переменная должна быть определена вне всех функций; при этом ей выделяется фактическое место в памяти. Такая переменная должна быть также описана в каждой функции, которая собирается ее использовать; это можно сделать либо явным описанием extern, либо неявным по контексту. Чтобы сделать обсуждение более конкретным, давайте перепишем программу поиска самой длинной строки, сделав line, save и max внешними переменными. Это потребует изменения описаний и тел всех трех функций, а также обращений к ним.</p>
		<blockquote>
			<pre class="cpp">#define MAXLINE 1000   /* max. input line size*/

char line[MAXLINE];  /* input line */
char save[MAXLINE];  /* longest line saved here*/
int  max;/*length of longest line seen so far*/

main()  /*find longest line; specialized version*/
{
  int  len;
  extern int max;
  extern char save[];
  max = 0;
  while ( (len = getline()) > 0 )
    if ( len > max )  {
      max = len;
      copy();
    }
  if ( max > 0 )  /* there was a line */
    printf( "%s", save );
}

getline()  /* specialized version */
{
  int c, i;
  extern char line[];
  for (i = 0; i &lt; MAXLINE-1 && (c=getchar()) !=EOF && c!='\n'; ++i)
    line[i] = c;
  if (c == '\n')  {
    s[i] = c;
    ++i;
  }
  line[i] = '\0'
  return(i)
}

copy()  /* specialized version */
{
  int i;
  extern char line[], save[];
  i = 0;
  while ((save[i] = line[i]) !='\0')
    ++i;
}</pre>
		</blockquote>
		<p>Внешние переменные для функций main, getline и copy определены в первых строчках приведенного выше примера, которыми указывается их тип и вызывается отведение для них памяти. Синтаксически внешние описания точно такие же, как описания, которые мы использовали ранее, но так как они расположены вне функций, соответствующие переменные являются внешними. Чтобы функция могла использовать внешнюю переменную, ей надо сообщить ее имя. Один способ сделать это - включить в функцию описание extern; это описание отличается от предыдущих только добавлением ключевого слова extern.</p>
		<p>В определенных ситуациях описание extern может быть опущено: если внешнее определение переменной находится в том же исходном файле, раньше ее использования в некоторой конкретной функции, то не обязательно включать описание extern для этой переменной в саму функцию. Описания extern в функциях main, getline и copy являются, таким образом, излишними. Фактически, обычная практика заключается в помещении определений всех внешних переменных в начале исходного файла и последующем опускании всех описаний extern.</p>
<p>Если программа находится в нескольких исходных файлах, и некоторая переменная определена, скажем в файле 1, а используется в файле 2, то чтобы связать эти два вхождения переменной, необходимо в файле 2 использовать описание extern. Этот вопрос подробно обсуждается в <a href="../chapter4/4.html">главе&nbsp;4</a>.</p>
<p>Вы должно быть заметили, что мы в этом разделе при ссылке на внешние переменные очень аккуратно используем слова описание и определение. "Определение" относится к тому месту, где переменная фактически заводится и ей выделяется память; "описание" относится к тем местам, где указывается природа переменной, но никакой памяти не отводится.</p>
		<p>Между прочим, существует тенденция объявлять все, что ни попадется, внешними переменными, поскольку кажется, что это упрощает связи, - списки аргументов становятся короче и переменные всегда присутствуют, когда бы вам они ни понадобились. Но внешние переменные присутствуют и тогда, когда вы в них не нуждаетесь. Такой стиль программирования чреват опасностью, так как он приводит к программам, связи данных внутри которых не вполне очевидны. Переменные при этом могут изменяться неожиданным и даже неумышленным образом, а программы становится трудно модифицировать, когда возникает такая необходимость. Вторая версия программы поиска самой длинной строки уступает первой отчасти по этим причинам, а отчасти потому, что она лишила универсальности две весьма полезные функции, введя в них имена переменных, с которыми они будут манипулировать.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 1-18</span></p>
			<p>Проверка в операторе for функции getline довольно неуклюжа. Перепишите программу таким образом, чтобы сделать эту проверку более ясной, но сохраните при этом то же самое поведение в конце файла и при переполнении буфера. Является ли это поведение самым разумным?</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
