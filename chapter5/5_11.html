<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.11 Командная строка аргументов</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Системные средства, на которые опирается реализация язы-
ка C, позволяют передавать командную строку аргументов или
параметров начинающей выполняться программе. Когда функция
main вызывается к исполнению, она вызывается с двумя аргу-
ментами. Первый аргумент (условно называемый argc) указывает
число аргументов в командной строке, с которыми происходит
обращение к программе; второй аргумент (argv) является ука-
зателем на массив символьных строк, содержащих эти аргумен-
ты, по одному в строке. Работа с такими строками - это обыч-
ное использование многоуровневых указателей.
    Самую простую иллюстрацию этой возможности и необходимых
при этом описаний дает программа ECHO, которая просто печа-
тает в одну строку аргументы командной строки, разделяя их
пробелами. Таким образом, если дана команда

 echo hello, world

то выходом будет

 hello, world

по соглашению argv[0] является именем, по которому вызывает-
ся программа, так что argc по меньшей мере равен 1. В приве-
денном выше примере argc равен 3, а argv[0], argv[1] и
argv[2] равны соответственно "echo", "hello," и "world".
Первым фактическим агументом является argv[1], а последним -
argv[argc-1]. Если argc равен 1, то за именем программы не
следует никакой командной строки аргументов. Все это показа-
но в echo:

main(argc, argv) /* echo arguments; 1st version */
int argc;
char *argv[];
{
  int i;
  for (i = 1; i &lt; argc; i++)
    printf("%s%c", argv[i], (i&lt;argc-1) ? ' ' : '\n');
}

Поскольку argv является указателем на массив указателей, то
существует несколько способов написания этой программы, ис-
пользующих работу с указателем, а не с индексацией массива.
Мы продемонстрируем два варианта.

main(argc, argv) /* echo arguments; 2nd version */
int argc;
char *argv[];
{
  while (--argc > 0)
    printf("%s%c",*++argv, (argc > 1) ? ' ' : '\n');
}

Так как argv является указателем на начало массива строк-ар-
гументов, то, увеличив его на 1 (++argv), мы вынуждаем его
указывать на подлинный аргумент argv[1], а не на argv[0].
Каждое последующее увеличение передвигает его на следующий
аргумент; при этом *argv становится указателем на этот аргу-
мент. Одновременно величина argc уменьшается; когда она об-
ратится в нуль, все аргументы будут уже напечатаны.
    Другой вариант:

 main(argc, argv) /* echo arguments; 3rd version */
 int argc;
 char *argv[];
 {
   while (--argc > 0)
     printf((argc > 1) ? "%s" : "%s\n", *++argv);
 }

Эта версия показывает, что аргумент формата функции printf
может быть выражением, точно так же, как и любой другой. Та-
кое использование встречается не очень часто, но его все же
стоит запомнить.
    Как второй пример, давайте внесем некоторые усовершенст-
вования в программу отыскания заданной комбинации символов
из главы 4. Если вы помните, мы поместили искомую комбинацию
глубоко внутрь программы, что очевидно является совершенно
неудовлетворительным. Следуя утилите grep системы UNIX, да-
вайте изменим программу так, чтобы эта комбинация указыва-
лась в качестве первого аргумента строки.

 #define MAXLINE 1000

 main(argc, argv) /* find pattern from first argument */
 int argc;
 char *argv[];
 {
  char line[MAXLINE];
  if (argc != 2)
    printf ("usage: find pattern\n");
  else
    while (getline(line, MAXLINE) > 0)
      if (index(line, argv[1]) >= 0)
        printf("%s", line);
 }

    Теперь может быть развита основная модель, иллюстрирую-
щая дальнейшее использование указателей. Предположим, что
нам надо предусмотреть два необязательных аргумента. Один
утверждает: "напечатать все строки за исключением тех, кото-
рые содержат данную комбинацию", второй гласит: "перед каж-
дой выводимой строкой должен печататься ее номер".
    Общепринятым соглашением в C-программах является то,
что аргумент, начинающийся со знака минус, вводит необяза-
тельный признак или параметр. Если мы, для того, чтобы сооб-
щить об инверсии, выберем -x, а для указания о нумерации
нужных строк выберем -n("номер"), то команда

 find -x -n the

при входных данных

 now is the time
 for all good men
 to come to the aid
 of their party.

Должна выдать

 2:for all good men

    Нужно, чтобы необязательные аргументы могли располагать-
ся в произвольном порядке, и чтобы остальная часть программы
не зависела от количества фактически присутствующих аргумен-
тов. В частности, вызов функции index не должен содержать
ссылку на argv[2], когда присутствует один необязательный
аргумент, и на argv[1], когда его нет. Более того, для поль-
зователей удобно, чтобы необязательные аргументы можно было
объединить в виде:

 find -nx the

вот сама программа:

#define MAXLINE 1000

main(argc, argv) /* find pattern from first argument */
int argc;
char *argv[];
{
  char line[MAXLINE], *s;
  long lineno = 0;
  int except = 0, number = 0;
  while (--argc > 0 &amp;&amp; (*++argv)[0] == '-')
    for (s = argv[0]+1; *s != '\0'; s++)
      switch (*s) {
        case 'x':
          except = 1;
          break;
        case 'n':
          number = 1;
          break;
        default:
          printf("find: illegal option %c\n", *s);
          argc = 0;
          break;
      }
  if (argc != 1)
    printf("usage: find -x -n pattern\n");
  else
    while (getlinе(line, MAXLINE) > 0) {
      lineno++;
      if ((index(line, *argv) >= 0) != except) {
        if (number)
          printf("%ld: ", lineno);
        printf("%s", line);
      }
    }
}

    Аргумент argv увеличивается перед каждым необязательным
аргументом, в то время как аргумент argc уменьшается. Если
нет ошибок, то в конце цикла величина argc должна равняться
1, а *argv должно указывать на заданную комбинацию. Обратите
внимание на то, что *++argv является указателем аргументной
строки; (*++argv)[0] - ее первый символ. Круглые скобки
здесь необходимы, потому что без них выражение бы приняло
совершенно отличный (и неправильный) вид *++(argv[0]). Дру-
гой правильной формой была бы **++argv.

Упражнение 5-7
    Напишите программу add, вычисляющую обратное польское
выражение из командной строки. Например,

add 2 3 4 + *

вычисляет 2*(3+4).

Упражнение 5-8
    Модифицируйте программы entab и detab (указанные в ка-
честве упражнений в главе 1) так, чтобы они получали список
табуляционных остановок в качестве аргументов. Если аргумен-
ты отсутствуют, используйте стандартную установку табуляций.

Упражнение 5-9
    Расширьте entab и detab таким образом, чтобы они воспри-
нимали сокращенную нотацию

 entab m +n

означающую табуляционные остановки через каждые n столбцов,
начиная со столбца m. Выберите удобное (для пользователя)
поведение функции по умолчанию.

Упражнение 5-10
    Напишите программу для функции tail, печатающей послед-
ние n строк из своего файла ввода. Пусть по умолчанию n рав-
но 10, но это число может быть изменено с помощью необяза-
тельного аргумента, так что

 tail -n

печатает последние n строк. Программа должна действовать ра-
ционально, какими бы неразумными ни были бы ввод или значе-
ние n. Составьте программу так, чтобы она оптимальным обра-
зом использовала доступную память: строки должны храниться,
как в функции sort, а не в двумерном массиве фиксированного
размера.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
