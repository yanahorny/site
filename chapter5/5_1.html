<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.1 Указатели и адреса</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Так как указатель содержит адрес объекта, это дает воз-
можность "косвенного" доступа к этому объекту через указа-
тель. Предположим, что х - переменная, например, типа int, а
рх - указатель, созданный неким еще не указанным способом.
Унарная операция &amp; выдает адрес объекта, так что оператор

 рх = &х;

    присваивает адрес х переменной рх; говорят, что рх "ука-
зывает" на х. Операция &amp; применима только к переменным и
элементам массива, конструкции вида &amp;(х-1) и &amp;3 являются не-
законными. Нельзя также получить адрес регистровой перемен-
ной.
    Унарная операция * рассматривает свой операнд как адрес
конечной цели и обращается по этому адресу, чтобы извлечь
содержимое. Следовательно, если y тоже имеет тип int, то

 y = *рх;

присваивает y содержимое того, на что указывает рх. Так пос-
ледовательность

 рх = &х;
 y = *рх;

присваивает y то же самое значение, что и оператор

y = x;

Переменные, участвующие во всем этом необходимо описать:

int x, y;
int *px;

с описанием для x и y мы уже  неодонократно  встречались.
Описание указателя

int *px;

является новым и должно рассматриваться как мнемоническое;
оно говорит, что комбинация *px имеет тип int. Это означает,
что если px появляется в контексте *px, то это эквивалентно
переменной типа int. Фактически синтаксис описания перемен-
ной имитирует синтаксис выражений, в которых эта переменная
может появляться. Это замечание полезно во всех случаях,
связанных со сложными описаниями. Например,

double atof(), *dp;

говорит, что atof() и *dp имеют в выражениях значения типа
double.
     Вы должны также заметить, что из этого описания следу-
ет, что указатель может указывать только на определенный вид
объектов.
     Указатели могут входить в выражения. Например, если px
указывает на целое x, то *px может появляться в любом кон-
тексте, где может встретиться x. Так оператор

y = *px + 1

присваивает y значение, на 1 большее значения x;

printf("%d\n", *px)

печатает текущее значение x;

d = sqrt((double) *px)

получает в d квадратный корень из x, причем до передачи фун-
кции sqrt значение x преобразуется к типу double. (Смотри
главу 2).
    В выражениях вида

y = *px + 1

унарные операции * и &amp; связаны со своим операндом более
крепко, чем арифметические операции, так что такое выражение
берет то значение, на которое указывает px, прибавляет 1 и
присваивает результат переменной y. Мы вскоре вернемся к то-
му, что может означать выражение

 y = *(px + 1)

    Ссылки на указатели могут появляться и в левой части
присваиваний. Если px указывает на x, то

 *px = 0

полагает x равным нулю, а

 *px += 1

увеличивает его на единицу, как и выражение

 (*px)++

Круглые скобки в последнем примере необходимы; если их опус-
тить, то поскольку унарные операции, подобные * и ++, выпол-
няются справа налево, это выражение увеличит px, а не ту пе-
ременную, на которую он указывает.
    И наконец, так как указатели являются переменными, то с
ними можно обращаться, как и с остальными переменными. Если
py - другой указатель на переменную типа int, то

 py = px

копирует содержимое px в py, в результате чего py указывает
на то же, что и px.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>