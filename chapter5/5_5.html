<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.5 Указатели символов и функции</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Строчная константа, как, например,

 "i am a string"

является массивом символов. Компилятор завершает внутреннее
представление такого массива символом \0, так что программы
могут находить его конец. Таким образом, длина массива в па-
мяти оказывается на единицу больше числа символов между
двойными кавычками.
    По-видимому чаще всего строчные константы  появляются  в
качестве аргументов функций, как, например, в

 printf ("hello, world\n");

когда символьная строка, подобная этой, появляется в прог-
рамме, то доступ к ней осуществляется с помощью указателя
символов; функция printf фактически получает указатель сим-
вольного массива.
    Конечно, символьные массивы не обязаны быть только аргу-
ментами функций. Если описать message как

 char *message;

то в результате оператора

 message = "now is the time";

переменная message станет указателем на фактический массив
символов. Это не копирование строки; здесь участвуют только
указатели. В языке C не предусмотрены какие-либо операции
для обработки всей строки символов как целого.
    Мы проиллюстрируем другие аспекты указателей и массивов,
разбирая две полезные функции из стандартной библиотеки вво-
да-вывода, которая будет рассмотрена в главе 7.
    Первая функция - это strcpy(s,t), которая копирует стро-
ку <span lang="en-us">t</span> в строку s. Аргументы написаны именно в этом порядке по
аналогии с операцией присваивания, когда для того, чтобы
присвоить t к s обычно пишут

  s = t

 сначала приведем версию с массивами:

strcpy(s, t)    /* copy t to s */
char s[], t[];
{
   int i;
   i = 0;
   while ((s[i] = t[i]) != '\0')
       i++;
}

    Для  сопоставления ниже дается вариант strcpy с указате-
лями.

strcpy(s, t)  /* copy t to s; pointer version 1 */
char *s, *t;
{
   while ((*s = *t) != '\0') {
       s++;
       t++;
   }
}

    Так как аргументы передаются по значению, функция strcpy
может использовать s и t так, как она пожелает. Здесь они с
удобством полагаются указателями, которые передвигаются
вдоль массивов, по одному символу за шаг, пока не будет ско-
пирован в s завершающий в t символ \0.
    На практике функция strcpy была бы записана не так,  как
мы показали выше. Вот вторая возможность:

strcpy(s, t)  /* copy t to s; pointer version 2 */
char *s, *t;
{
   while ((*s++ = *t++) != '\0')
      ;
}

    Здесь увеличение s и t внесено в проверочную часть. Зна-
чением *t++ является символ, на который указывал t до увели-
чения; постфиксная операция ++ не изменяет t, пока этот сим-
вол не будет извлечен. Точно так же этот символ помещается в
старую позицию s, до того как s будет увеличено. Конечный
результат заключается в том, что все символы, включая завер-
шающий \0, копируются из t в S.
    И как последнее сокращение мы опять отметим, что сравне-
ние с \0 является излишним, так что функцию можно записать в
виде

strcpy(s, t)  /* copy t to s; pointer version 3 */
char *s, *T;
{
   while (*s++ = *t++)
           ;
}

хотя  с первого взгляда эта запись может показаться загадоч-
ной, она дает значительное удобство.  Этой  идиомой  следует
овладеть  уже хотя бы потому, что вы с ней будете часто вст-
речаться в C-программах.
    Вторая функция - strcmp(s, t), которая сравнивает сим-
вольные строки s и <span lang="en-us">t</span>, возвращая отрицательное, нулевое или
положительное значение в соответствии с тем, меньше, равно
или больше лексикографически s, чем t. Возвращаемое значение
получается в результате вычитания символов из первой пози-
ции, в которой s и t не совпадают.

strcmp(s, t) /* return &lt;0 if s&lt;t, 0 if s==t, >0 if s>t */
char s[], t[];
{
 int i;
 i = 0;
 while (s[i] == t[i])
    if (s[i++] == '\0')
        return(0);
 return(s[i]-t[i]);
}

Вот версия strcmp с указателями:

strcmp(s, t) /* return &lt;0 if s&lt;t, 0 if s==t, >0 if s>t */
char *s, *t;
{
 for ( ; *s == *t; s++, t++)
    if (*s == '\0')
        return(0);
 return(*s-*t);
}

     так как ++ и -- могут быть как постфиксными,  так  и
префиксными операциями, встречаются другие комбинации * и
++ и --, хотя и менее часто.

Например

 *++p

увеличивает p до извлечения символа, на который указывает

p, а

 *--p

сначала уменьшает p.

Упражнение 5-2
    Напишите  вариант  с указателями функции strcat из главы
2: strcat(s, t) копирует строку t в конец <span lang="en-us">s</span>.

Упражнение 5-3
    Напишите макрос для strcpy.

Упражнение 5-4
    Перепишите подходящие программы из предыдущих глав и уп-
ражнений,  используя  указатели  вместо индексации массивов.
Хорошие возможности для этого предоставляют функции  getline
(главы  1  и  4), atoi, itoa и их варианты (главы 2, 3 и 4),
reverse (глава 3), index и getop (глава 4).
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
