<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.3 Указатели и массивы</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    В языке C существует сильная взаимосвязь между указа-
телями и массивами, настолько сильная, что указатели и мас-
сивы действительно следует рассматривать одновременно. Любую
операцию, которую можно выполнить с помощью индексов масси-
ва, можно сделать и с помощью указателей. Вариант с указате-
лями обычно оказывается более быстрым, но и несколько более
трудным для непосредственного понимания, по крайней мере для
начинающего. Описание

int a[10]

определяет  массив  размера  10, т.е. Набор из 10 последова-
тельных объектов, называемых a[0], a[1], ...,  a[9].  Запись
a[i] соответствует элементу массива через i позиций от нача-
ла. Если pa - указатель целого, описанный как

   int *pa

то присваивание

   pa = &amp;a[0]

приводит к тому, что pa указывает на нулевой элемент массива
a; это означает, что pa содержит адрес элемента a[0]. Теперь
присваивание

   x = *pa

будет копировать содержимое a[0] в x.
    Если pa указывает на некоторый определенный элемент мас-
сива  a,  то по определению pa+1 указывает на следующий эле-
мент, и вообще pa-i указывает на элемент, стоящий на i пози-
ций до элемента, указываемого pa, а pa+i на элемент, стоящий
на i позиций после. Таким  образом,  если  pa  указывает  на
a[0], то

   *(pa+1)

ссылается на содержимое a[1], pa+i - адрес a[i], а *(pa+i) -
содержимое a[i].
    Эти замечания справедливы независимо от типа переменных
в массиве a. Суть определения "добавления 1 к указателю", а
также его распространения на всю арифметику указателей, сос-
тоит в том, что приращение масштабируется размером памяти,
занимаемой объектом, на который указывает указатель. Таким
образом, i в pa+i перед прибавлением умножается на размер
объектов, на которые указывает pa.
    Очевидно существует очень тесное соответствие между ин-
дексацией и арифметикой указателей. В действительности ком-
пилятор преобразует ссылку на массив в указатель на начало
массива. В результате этого имя массива является указатель-
ным выражением. Отсюда вытекает несколько весьма полезных
следствий. Так как имя массива является синонимом местополо-
жения его нулевого элемента, то присваивание pa=&amp;a[0] можно
записать как

    pa = a

    Еще более удивительным, по крайней мере на первый взг-
ляд, кажется тот факт, что ссылку на a[i] можно записать в
виде *(a+i). При анализировании выражения a[i] в языке C
оно немедленно преобразуется к виду *(a+i); эти две формы
совершенно эквивалентны. Если применить операцию &amp; к обеим
частям такого соотношения эквивалентности, то мы получим,
что &amp;a[i] и a+i тоже идентичны: a+i - адрес i-го элемента от
начала a. С другой стороны, если pa является указателем, то
в выражениях его можно использовать с индексом: pa[i] иден-
тично *(pa+i). Короче, любое выражение, включающее массивы и
индексы, может быть записано через указатели и смещения и
наоборот, причем даже в одном и том же утверждении.
    Имеется одно различие между именем массива и указателем,
которое необходимо иметь в виду. Указатель является перемен-
ной, так что операции pa=a и pa++ имеют смысл. Но имя масси-
ва является константой, а не переменной: конструкции типа
a=pa или a++, или p=&amp;a будут незаконными.
    Когда имя массива передается функции, то на самом деле
ей передается местоположение начала этого массива. Внутри
вызванной функции такой аргумент является точно такой же пе-
ременной, как и любая другая, так что имя массива в качестве
аргумента действительно является указателем, т.е. перемен-
ной, содержащей адрес. Мы можем использовать это обстоятель-
ство для написания нового варианта функции strlen, вычисляю-
щей длину строки.

 strlen(s)       /* return length of string s */
 char *s;
 {
    int n;
    for (n = 0; *s != '\0'; s++)
        n++;
    return(n);
 }

    Операция увеличения s совершенно законна, поскольку эта
переменная является указателем; s++ никак не влияет на сим-
вольную строку в обратившейся к strlen функции, а только
увеличивает локальную для функции strlen копию адреса. Опи-
сания формальных параметров в определении функции в виде

char s[];
char *s;

совершенно эквивалентны; какой вид описания следует предпо-
честь, определяется в значительной степени тем, какие выра-
жения будут использованы при написании функции. Если функции
передается имя массива, то в зависимости от того, что удоб-
нее, можно полагать, что функция оперирует либо с массивом,
либо с указателем, и действовать далее соответвующим обра-
зом. Можно даже использовать оба вида операций, если это ка-
жется уместным и ясным.
    Можно передать функции часть массива, если задать в ка-
честве аргумента указатель начала подмассива. Например, если
a - массив, то как

f(&amp;a[2])

как и

f(a+2)

передают  функции f адрес элемента a[2], потому что и &amp;a[2],
и a+2 являются указательными  выражениями,  ссылающимися  на
третий элемент a. Внутри функции f описания аргументов могут
присутствовать в виде:

f(arr)
int arr[];
{
   ...
}

или

f(arr)
int *arr;
{
   ...
}

Что касается функции f, то тот факт, что ее аргумент в дейс-
твительности ссылается к части большего массива, не имеет для
нее никаких последствий.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
