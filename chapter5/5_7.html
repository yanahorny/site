<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.7 Многомерные массивы</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    В языке C предусмотрены прямоугольные многомерные мас-
сивы, хотя на практике существует тенденция к их значительно
более  редкому использованию по сравнению с массивами указа-
телей. В этом разделе мы рассмотрим некоторые их свойства.
    Рассмотрим задачу преобразования дня месяца в день  года
и  наоборот. Например, 1-ое марта является 60-м днем невисо-
косного года и 61-м днем високосного  года.  Давайте  введем
две  функции для выполнения этих преобразований: day_of_year
преобразует месяц и день в день года, а month_day преобразу-
ет  день  года в месяц и день. Так как эта последняя функция
возвращает два значения, то аргументы месяца  и  дня  должны
быть указателями:

 month_day(1977, 60, &amp;m, &amp;d)

Полагает m равным 3 и d равным 1 (1-ое марта).
    Обе эти функции нуждаются в одной и той же информацион-
ной таблице, указывающей число дней в каждом месяце. Так как
число дней в месяце в високосном и в невисокосном году отли-
чается, то проще представить их в виде двух строк двумерного
массива, чем пытаться прослеживать во время вычислений, что
именно происходит в феврале. Вот этот массив и выполняющие
эти преобразования функции:

static int day_tab[2][13] = {
  {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
  {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};


day_of_year(year, month, day)   /* set day of year */
int year, month, day;           /* from month &amp; day */
{
  int i, leap;
  leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;
  for (i = 1; i &lt; month; i++)
    day += day_tab[leap][i];
  return(day);
}

month_day(year, yearday, pmonth, pday) /*set month,day */
int year, yearday, *pmonth, *pday; /* from day of year */
{
  leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 == 0;
  for (i = 1; yearday > day_tab[leap][i]; i++)
    yearday -= day_tab[leap][i];
  *pmonth = i;
  *pday = yearday;
}

Массив  day_tab должен быть внешним как для day_of_year, так
и для month_day, поскольку он используется обеими этими фун-
кциями.
    Массив day_tab является первым двумерным массивом, с ко-
торым мы имеем дело. По определению в C  двумерный  массив
по существу является одномерным массивом, каждый элемент ко-
торого является массивом. Поэтому индексы записываются как

day_tab[i][<span lang="en-us">j</span>]

а не

day_tab [i, <span lang="en-us">j</span>]

как в большинстве языков. В остальном с двумерными массивами
можно  в  основном обращаться таким же образом, как в других
языках. Элементы хранятся по строкам, т.е. при  обращении  к
элементам в порядке их размещения в памяти быстрее всего из-
меняется самый правый индекс.
    Массив инициализируется с помощью списка начальных  зна-
чений,  заключенных в фигурные скобки; каждая строка двумер-
ного массива инициализируется соответствующим подсписком. Мы
поместили  в начало массива day_tab столбец из нулей для то-
го, чтобы номера месяцев изменялись естественным образом  от
1  до  12, а не от 0 до 11. Так как за экономию памяти у нас
пока не награждают, такой способ проще, чем подгонка  индек-
сов.
    Если двумерный массив передается функции, то описание
соответствующего аргумента функции должно содержать количес-
тво столбцов; количество строк несущественно, поскольку, как
и прежде, фактически передается указатель. В нашем конкрет-
ном случае это указатель объектов, являющихся массивами из
13 чисел типа int. Таким образом, если бы требовалось пере-
дать массив day_tab функции f, то описание в f имело бы вид:

f(day_tab)
int day_tab[2][13];
{
   ...
}

Так  как количество строк является несущественным, то описа-
ние аргумента в f могло бы быть таким:

 int day_tab[][13];

или таким

 int (*day_tab)[13];

в которм говорится, что аргумент является указателем массива
из  13  целых.  Круглые  скобки здесь необходимы, потому что
квадратные скобки [] имеют более высокий уровень  старшинст-
ва,  чем  *;  как мы увидим в следующем разделе, без круглых
скобок

 int *day_tab[13];

является описанием массива из 13 указателей на целые.
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
