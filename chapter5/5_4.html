<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>5.4 Адресная арифметика</title>
		<link href="../style.css"  rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Если p является указателем, то каков бы ни был сорт
объекта, на который он указывает, операция p++ увеличивает p
так, что он указывает на следующий элемент набора этих
объектов, а операция p +=i увеличивает p так, чтобы он ука-
зывал на элемент, отстоящий на i элементов от текущего эле-
мента. Эти и аналогичные конструкции представляют собой самые
простые и самые распространенные формы арифметики указателей
или адресной арифметики.
    Язык C последователен и постоянен в своем подходе к
адресной арифметике; объединение в одно целое указателей,
массивов и адресной арифметики является одной из наиболее
сильных сторон языка. Давайте проиллюстрируем некоторые из
соответствующих возможностей языка на примере элементарной
(но полезной, несмотря на свою простоту) программы распреде-
ления памяти. Имеются две функции: функция alloc(n) возвра-
щает в качестве своего значения указатель p, который указы-
вает на первую из n последовательных символьных позиций, ко-
торые могут быть использованы вызывающей функцию alloc прог-
раммой для хранения символов; функция free(p) освобождает
приобретенную таким образом память, так что ее в дальнейшем
можно снова использовать. Программа является "элементарной",
потому что обращения к free должны производиться в порядке,
обратном тому, в котором производились обращения к alloc.
Таким образом, управляемая функциями alloc и free память яв-
ляется стеком или списком, в котором последний вводимый эле-
мент извлекается первым. Стандартная библиотека языка C
содержит аналогичные функции, не имеющие таких ограничений,
и, кроме того, в главе 8 мы приведем улучшенные варианты.
Между тем, однако, для многих приложений нужна только триви-
альная функция alloc для распределения небольших участков
памяти неизвестных заранее размеров в непредсказуемые момен-
ты времени.
    Простейшая реализация состоит в том, чтобы функция раз-
давала отрезки большого символьного массива, которому мы
присвоили имя allocbuf. Этот массив является собственностью
функций alloc и free. Так как они работают с указателями, а
не с индексами массива, никакой другой функции не нужно
знать имя этого массива. Он может быть описан как внешний
статический, т.е. он будет локальным по отношению к исходно-
му файлу, содержащему alloc и free, и невидимым за его пре-
делами. При практической реализации этот массив может даже
не иметь имени; вместо этого он может быть получен в резуль-
тате запроса к операционной системе на указатель некоторого
неименованного блока памяти.
    Другой необходимой информацией является то, какая часть
массива allocbuf уже использована. Мы пользуемся указателем
первого свободного элемента, названным allocp. Когда к функ-
ции alloc обращаются за выделением n символов, то она прове-
ряет, достаточно ли осталось для этого места в allocbuf. Ес-
ли достаточно, то alloc возвращает текущее значение allocp
(т.е. начало свободного блока), затем увеличивает его на n,
с тем чтобы он указывал на следующую свободную область. Фун-
кция free(p) просто полагает allocp равным p при условии,
что p указывает на позицию внутри allocbuf.

#define NULL 0  /* pointer value for error report */
#define ALLOCSIZE 1000  /* size of available space */

static char allocbuf[ALLOCSIZE];/* storage for alloc */
static char *allocp = allocbuf; /* next free position */

char *alloc(n)  /* return pointer to n characters */
int n;
{
 if (allocp + n &lt;= allocbuf + ALLOCSIZE) {
   allocp += n;
   return(allocp - n); /* old p */
} else         /* not enough room */
   return(NULL);
}

free(p)    /* free storage pointed by p */
char *p;
{
 if (p >= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
    allocp = p;
}

    Дадим некоторые пояснения. Вообще говоря, указатель мо-
жет быть инициализирован точно так же, как и любая другая
переменная, хотя обычно единственными осмысленными значения-
ми являются NULL (это обсуждается ниже) или выражение, вклю-
чающее адреса ранее определенных данных соответствующего ти-
па. Описание

 static char *allocp = allocbuf;

определяет allocp как указатель на символы и инициализирует
его так, чтобы он указывал на allocbuf, т.е. на первую сво-
бодную позицию при начале работы программы. Так как имя мас-
сива является адресом его нулевого элемента, то это можно
было бы записать в виде

    static char *allocp = &amp;allocbuf[0];

Используйте  ту запись, которая вам кажется более естествен-
ной. С помощью проверки

  if (allocp + n &lt;= allocbuf + ALLOCSIZE)

выясняется, осталось ли достаточно места, чтобы удовлетво-
рить запрос на n символов. Если достаточно, то новое значе-
ние allocp не будет указывать дальше, чем на последнюю пози-
цию allocbuf. Если запрос может быть удовлетворен, то alloc
возвращает обычный указатель (обратите внимание на описание
самой функции). Если же нет, то alloc должна вернуть некото-
рый признак, говорящий о том, что больше места не осталось.
В языке C гарантируется, что ни один правильный указатель
данных не может иметь значение нуль, так что возвращение ну-
ля может служить в качестве сигнала о ненормальном событии,
в данном случае об отсутствии места. Мы, однако, вместо нуля
пишем NULL, с тем чтобы более ясно показать, что это специ-
альное значение указателя. Вообще говоря, целые не могут ос-
мысленно присваиваться указателям, а нуль - это особый слу-
чай.
    Проверки вида

 if (allocp + n &lt;= allocbuf + ALOOCSIZE)
и
 if (p >= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)

демонстрируют несколько важных аспектов арифметики указате-
лей. Во-первых , при определенных условиях указатели можно
сравнивать. Если p и q указывают на элементы одного и того
же массива, то такие отношения, как &lt;, >= и т.д., работают
надлежащим образом. Например,

 p &lt; q

истинно, если p указывает на более ранний элемент массива,
чем q. Отношения == и != тоже работают. Любой указатель мож-
но осмысленным образом сравнить на равенство или неравенство
с NULL. Но ни за что нельзя ручаться, если вы используете
сравнения при работе с указателями, указывающими на разные
массивы. Если вам повезет, то на всех машинах вы получите
очевидную бессмыслицу. Если же нет, то ваша программа будет
правильно работать на одной машине и давать непостижимые ре-
зультаты на другой.
     Во-вторых, как мы уже видели, указатель и  целое  можно
складывать и вычитать. Конструкция

 p + n

подразумевает n-ый объект за тем, на который p указывает в
настоящий момент. Это справедливо независимо от того, на ка-
кой вид объектов p должен указывать; компилятор сам масшта-
бирует n в соответствии с определяемым из описания p разме-
ром объектов, указываемых с помощью p. Например, на PDP-11
масштабирующий множитель равен 1 для char, 2 для int и
short, 4 для long и float и 8 для double.
    Вычитание указателей тоже возможно: если p и q указывают
на элементы одного и того же массива, то  p-q  -  количество
элементов  между p и q. Этот факт можно использовать для на-
писания еще одного варианта функции strlen:

  strlen(s)       /* return length of string s */
  char *s;
  {
     char *p = s;
     while (*p != '\0')
         p++;
     return(p-s);
  }

    При описании указатель p в этой функции инициализирован
посредством строки s, в результате чего он указывает на пер-
вый символ строки. В цикле while по очереди проверяется каж-
дый символ до тех пор, пока не появится символ конца строки
\0. Так как значение \0 равно нулю, а while только выясняет,
имеет ли выражение в нем значение 0, то в данном случае яв-
ную проверку можно опустить. Такие циклы часто записывают в
виде

while (*p)
   p++;

    Так как p указывает на символы, то оператор p++ передви-
гает p каждый раз так, чтобы он указывал на  следующий  сим-
вол.  В  результате  p-s  дает число просмотренных символов,
т.е. длину строки.  Арифметика  указателей  последовательна:
если  бы мы имели дело с переменными типа float, которые за-
нимают больше памяти, чем переменные типа char, и если бы  p
был  указателем на float, то оператор p++ передвинул бы p на
следующее float. Таким образом, мы могли бы написать  другой
вариант  функции  alloc,  распределяющей  память  для float,
вместо char, просто заменив всюду в alloc и  free  описатель
char на float. Все действия с указателями автоматически учи-
тывают размер объектов, на которые они  указывают,  так  что
больше ничего менять не надо.
    За исключением упомянутых выше операций (сложение и вы-
читание указателя и целого, вычитание и сравнение двух ука-
зателей), вся остальная арифметика указателей является неза-
конной. Запрещено складывать два указателя, умножать, де-
лить, сдвигать или маскировать их, а также прибавлять к ним
переменные типа float или double.</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
