<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>2.7 Преобразование типов</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>Если в выражениях встречаются операнды различных типов, то они преобразуются к общему типу в соответствии с небольшим набором правил. В общем, автоматически производятся только преобразования имеющие смысл, такие как, например, преобразование целого в плавающее в выражениях типа f+i. Выражения же, лишенные смысла, такие как использование переменной типа float в качестве индекса, запрещены.</p>
		<p>Во-первых, типы char и int могут свободно смешиваться в арифметических выражениях: каждая переменная типа char автоматически преобразуется в int. Это обеспечивает значительную гибкость при проведении определенных преобразований символов. Примером может служить функция atoi, которая ставит в соответствие строке цифр ее численный эквивалент.</p>
		<blockquote>
			<pre class="cpp">atoi(s)         /* convert s to integer */
char s[];
{
  int i, n;
  n = 0;
  for ( i = 0; s[i]>='0' && s[i]&lt;='9'; ++i)
    n = 10 * n + s[i] - '0';
  return(n);
}</pre>
		</blockquote>
		<p>Kак уже обсуждалось в главе 1, выражение</p>
		<blockquote>
			<pre>s[i] - '0'</pre>
		</blockquote>

<p>имеет численное значение находящегося в s[i] символа, потому что значение символов '0', '1' и т.д. образуют возрастающую последовательность расположенных подряд целых положительных чисел.</p>
		<p>Другой пример преобразования char в int дает функция lower, преобразующая данную прописную букву в строчную. Если выступающий в качестве аргумента символ не является прописной буквой, то lower возвращает его неизменным. Приводимая ниже программа справедлива только для набора символов ASCII.</p>
		<blockquote>
			<pre class="cpp">lower(c) /* convert c to lower case; ascii only */
int c;
{
  if ( c >= 'a' && c &lt;= 'z' )
    return( c + 'a' - 'A');
  else
    return(c);
}</pre>
		</blockquote>
		<p>Эта функция правильно работает при коде ASCII, потому что численные значения, соответствующие в этом коде прописным и строчным буквам, отличаются на постоянную величину, а каждый алфавит является сплошным - между а и Z нет ничего, кроме букв. Это последнее замечание для набора символов EBCDIC систем IBM 360/370 оказывается несправедливым, в силу чего эта программа на таких системах работает неправильно - она преобразует не только буквы.</p>
		<p>При преобразовании символьных переменных в целые возникает один тонкий момент. Дело в том, что сам язык не указывает, должны ли переменным типа char соответствовать численные значения со знаком или без знака. Может ли при преобразовании char в int получиться отрицательное целое? К сожалению, ответ на этот вопрос меняется от машины к машине, отражая расхождения в их архитектуре. На некоторых машинах (PDP-11, например) переменная типа char, крайний левый бит которой содержит 1, преобразуется в отрицательное целое ("знаковое расширение"). На других машинах такое преобразование сопровождается добавлением нулей с левого края, в результате чего всегда получается положительное число.</p>
<p>Определение языка C гарантирует, что любой символ из стандартного набора символов машины никогда не даст отрицательного числа, так что эти символы можно свободно использовать в выражениях как положительные величины. Но произвольные комбинации двоичных знаков, хранящиеся как символьные переменные на некоторых машинах, могут дать отрицательные значения, а на других положительные.</p>
		<p>Наиболее типичным примером возникновения такой ситуации является случай, когда значение 1 используется в качестве EOF. Рассмотрим программу</p>
		<blockquote>
			<pre>char c;
c = getchar();
if ( c == EOF )
  ...</pre>
		</blockquote>
		<p>На машине, которая не осуществляет знакового расширения, переменная c всегда положительна, поскольку она описана как char, а так как EOF отрицательно, то условие никогда не выполняется. Чтобы избежать такой ситуации, мы всегда предусмотрительно использовали int вместо char для любой переменной, получающей значение от getchar.</p>
		<p>Основная же причина использования int вместо char не связана с каким-либо вопросом о возможном знаковом расширении. Просто функция getchar должна передавать все возможные символы (чтобы ее можно было использовать для произвольного ввода) и, кроме того, отличающееся значение EOF. Следовательно значение EOF не может быть представлено как char, а должно храниться как int.</p>
<p>Другой полезной формой автоматического преобразования типов является то, что выражения отношения, подобные i>j, и логические выражения, связанные операциями && и ||, по определению имеют значение 1, если они истинны, и 0, если они ложны. Таким образом, присваивание</p>

<blockquote>
			<pre>isdigit = C >= '0' && C &lt;= '9';</pre>
		</blockquote>

<p>полагает isdigit равным 1, если с - цифра, и равным 0 в противном случае. (В проверочной части операторов if, while, for и т.д. "истинно" просто означает "не нуль").</p>
<p>Неявные арифметические преобразования работают в основном, как и ожидается. В общих чертах, если операция типа + или *, которая связывает два операнда (бинарная операция), имеет операнды разных типов, то перед выполнением операции "низший" тип преобразуется к "высшему" и получается результат "высшего" типа. Более точно, к каждой арифметической операции применяется следующая последовательность правил преобразования.</p>
<ul type=circle>
  <li>Типы char и short преобразуются в int, а float в double.</li>
  <li>Затем, если один из операндов имеет тип double, то другой преобразуется в double, и результат имеет тип double.</li>
  <li>В противном случае, если один из операндов имеет тип long, то другой преобразуется в long, и результат имеет тип long.</li>
  <li>В противном случае, если один из операндов имеет тип unsigned, то другой преобразуется в unsigned и результат имеет тип unsigned.</li>
  <li>В противном случае операнды должны быть типа int, и результат имеет тип int.</li>
</ul>
<p>Подчеркнем, что все переменные типа float в выражениях преобразуются в double; в C вся плавающая арифметика выполняется с двойной точностью.</p>
		<p>Преобразования возникают и при присваиваниях; значение правой части преобразуется к типу левой, который и является типом результата. Символьные переменные преобразуются в целые либо со знаковым расширением, либо без него, как описано выше. Обратное преобразование int в char ведет себя хорошо - лишние биты высокого порядка просто отбрасываются. Таким образом</p>
		<blockquote>
			<pre>int i;
char c;
i = c;
c = i;</pre>
		</blockquote>
		<p>значение c не изменяется. Это верно независимо от того, вовлекается ли знаковое расширение или нет.</p>
		<p>Если х типа float, а i типа int, то как</p>

<blockquote>
			<pre>х = i;</pre>
		</blockquote>

<p>так и</p>

<blockquote>
			<pre>i = х;</pre>
		</blockquote>

<p>приводят к преобразованиям; при этом float преобразуется в int отбрасыванием дробной части. Тип double преобразуется во float округлением. Длинные целые преобразуются в более короткие целые и в переменные типа char посредством отбрасывания лишних битов высокого порядка.</p>
<p>Так как аргумент функции является выражением, то при передаче функциям аргументов также происходит преобразование типов: в частности, char и short становятся int, а float становится double. Именно поэтому мы описывали аргументы функций как int и double даже тогда, когда обращались к ним с переменными типа char и float.</p>
<p>Наконец, в любом выражении может быть осуществлено ("принуждено") явное преобразование типа с помощью конструкции, называемой перевод (CAST). В этой конструкции, имеющей вид</p>

<blockquote>
			<pre>(<em>имя типа</em>) <em>выражение</em></pre>
		</blockquote>

<p><em>выражение</em> преобразуется к указанному типу по правилам преобразования, изложенным выше. Фактически точный смысл операции перевода можно описать следующим образом: выражение как бы присваивается некоторой переменной указанного типа, которая затем используется вместо всей конструкции. Например, библиотечная процедура sqrt ожидает аргумента типа double и выдаст бессмысленный ответ, если к ней по небрежности обратятся с чем-нибудь иным. Таким образом, если n - целое, то выражение</p>

<blockquote>
			<pre>sqrt((double) n)</pre>
		</blockquote>
		<p>до передачи аргумента функции sqrt преобразует n к типу double. (Отметим, что операция перевод преобразует значение n в надлежащий тип; фактическое содержание переменной n при этом не изменяется). Операция перевода имеет тот же уровень старшинства, что и другие унарные операции, как указывается в <a href="2_12.html">таблице</a> в конце этой главы.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 2-2</span></p>
			<p>Составьте программу для функции htoi(s), которая преобразует строку шестнадцатеричных цифр в эквивалентное ей целое значение. При этом допустимыми цифрами являются цифры от 1 до 9 и буквы от а до f.</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>