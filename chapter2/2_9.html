<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>2.9 Побитовые логические операции</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
<p>В языке предусмотрен ряд операций для работы с битами; эти операции нельзя применять к переменным типа float или double.</p>

<blockquote><table class="intext" border="0" cellspacing="1">
			<tr>
				<td class="cellcaption" align="center">&amp;</td>
				<td class="celltext">побитовое И</td>
			</tr>
			<tr>
				<td class="cellcaption" align="center">|</td>
				<td class="celltext">побитовое  включающее ИЛИ</td>
			</tr>
			<tr>
				<td class="cellcaption" align="center">^</td>
				<td class="celltext">побитовое исключающее ИЛИ</td>
			</tr>
			<tr>
				<td class="cellcaption" align="center">&lt;&lt;</td>
				<td class="celltext">сдвиг влево</td>
			</tr>
			<tr>
				<td class="cellcaption" align="center">&gt;&gt;</td>
				<td class="celltext">сдвиг вправо</td>
			</tr>
			<tr>
				<td class="cellcaption" align="center">~</td>
				<td class="celltext">дополнение (унарная операция)</td>
			</tr>
		</table></blockquote>
<p>Побитовая операция И часто используется для маскирования некоторого множества битов; например, оператор</p>

<blockquote>
			<pre>c = n &amp; 0177</pre>
		</blockquote>

<p>передает в c семь младших битов n, полагая остальные равными нулю. Операция | побитового ИЛИ используется для включения битов:</p>

<blockquote>
			<pre>c = x | MASK</pre>
		</blockquote>

<p>устанавливает в единицу те биты в х, которые равны единице в MASK.</p>
<p>Следует быть внимательным и отличать побитовые операции &amp; и | от логических связок &amp;&amp; и ||, которые подразумевают вычисление значения истинности слева направо. Например, если х=1, а y=2, то значение х&amp;y равно нулю, в то время как значение x&amp;&amp;y равно единице (почему?).</p>
<p>Операции сдвига &lt;&lt; и >> осуществляют соответственно сдвиг влево и вправо своего левого операнда на число битовых позиций, задаваемых правым операндом. Таким образом, х&lt;&lt;2 сдвигает х влево на две позиции, заполняя освобождающиеся биты нулями, что эквивалентно умножению на 4. Сдвиг вправо величины без знака заполняет освобождающиеся биты на некоторых машинах, таких как PDP-11, заполняются содержанием знакового бита ("арифметический сдвиг"), а на других - нулем ("логический сдвиг").</p>
<p>Унарная операция ~ дает дополнение к целому; это означает, что каждый бит со значением 1 получает значение 0 и наоборот. Эта операция обычно оказывается полезной в выражениях типа</p>

<blockquote>
			<pre>x &amp; ~077</pre>
		</blockquote>

<p>где последние шесть битов х маскируются нулем. Подчеркнем, что выражение x&amp;~077 не зависит от длины слова и поэтому предпочтительнее, чем, например, x&amp;0177700, где предполагается, что х занимает 16 битов. Такая переносимая форма не требует никаких дополнительных затрат, поскольку ~077 является константным выражением и, следовательно, обрабатывается во время компиляции.</p>
		<p>Чтобы проиллюстрировать использование некоторых операций с битами, рассмотрим функцию getbits(x,p,n), которая возвращает (сдвинутыми к правому краю) начинающиеся с позиции р поле переменной х длиной n битов. Мы предполагаем, что крайний правый бит имеет номер 0, и что n и р - разумно заданные положительные числа. например, getbits(х,4,3) возвращает сдвинутыми к правому краю биты, занимающие позиции 4,3 и 2.</p>
		<blockquote>
			<pre class="cpp">getbits(x,p,n)  <span class="comment">/* get n bits from position p */</span>
unsigned x, p, n;
{
  return((x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n));
}</pre>
		</blockquote>
		<p>Операция x >> (p+1-n) сдвигает желаемое поле в правый конец слова. Описание аргумента x как unsigned гарантирует, что при сдвиге вправо освобождающиеся биты будут заполняться нулями, а не содержимым знакового бита, независимо от того, на какой машине пропускается программа. Все биты константного выражения ~0 равны 1; сдвиг его на n позиций влево с помощью операции ~0&lt;&lt;n создает маску с нулями в n крайних правых битах и единицами в остальных; дополнение ~ создает маску с единицами в n крайних правых битах.</p>
		<div class="exercise">
			<p><span class="exercisetitle">Упражнение 2-5</span></p>
			<p>Переделайте getbits таким образом, чтобы биты отсчитывались слева направо.</p>
			<p><span class="exercisetitle">Упражнение 2-6</span></p>
			<p>Напишите программу для функции wordlength(), вычисляющей длину слова используемой машины, т.е. число битов в переменной типа int. Функция должна быть переносимой, т.е. одна и та же исходная программа должна правильно работать на любой машине.</p>
			<p><span class="exercisetitle">Упражнение 2-7</span></p>
			<p>Напишите программу для функции rightrot(n,b), сдвигающей циклически целое n вправо на b битовых позиций.</p>
			<p><span class="exercisetitle">Упражнение 2-8</span></p>
			<p>Напишите программу для функции invert(x,p,n), которая инвертирует (т.е. заменяет 1 на 0 и наоборот) n битов x, начинающихся с позиции p, оставляя другие биты неизмененными.</p>
		</div>
		<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
