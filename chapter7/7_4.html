<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>7.4 Форматный ввод - функция scanf</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Осуществляющая ввод функция scanf является аналогом
printf и позволяет проводить в обратном направлении многие
из тех же самых преобразований. Функция

scanf(control, arg1, arg2, ...)

читает символы из стандартного ввода, интерпретирует их в
соответствии с форматом, указанном в аргументе control, и
помещает результаты в остальные аргументы. Управляющий аргу-
мент описывается ниже; другие аргументы, каждый из которых
должен быть указателем, определяют, куда следует поместить
соответствующим образом преобразованный ввод.
    Управляющая строка обычно содержит спецификации преобра-
зования, которые используются для непосредственной интерпре-
тации входных последовательностей. Управляющая строка может
содержать:

- пробелы, табуляции или символы новой строки (&quot;символы пус-
  тых промежутков&quot;), которые игнорируются.
- Обычные символы (не %), которые предполагаются совпадающи-
  ми со следующими отличными от символов пустых промежутков
  символами входного потока.
- Спецификации преобразования, состоящие из символа %, нео-
  бязательного символа подавления присваивания *, необяза-
  тельного числа, задающего максимальную ширину поля и сим-
  вола преобразования.

    Спецификация преобразования управляет преобразованием
следующего поля ввода. Нормально результат помещается в пе-
ременную, которая указывается соответствующим аргументом.
Если, однако, с помощью символа * указано подавление прис-
ваивания, то это поле ввода просто пропускается и никакого
присваивания не производится. Поле ввода определяется как
строка символов, которые отличны от символов простых проме-
жутков; оно продолжается либо до следующего символа пустого
промежутка, либо пока не будет исчерпана ширина поля, если
она указана. Отсюда следует, что при поиске нужного ей вво-
да, функция scanf будет пересекать границы строк, поскольку
символ новой строки входит в число пустых промежутков.
    Символ преобразования определяет интерпретацию поля вво-
да; согласно требованиям основанной на вызове по значению
семантики языка C соответствующий аргумент должен быть
указателем. Допускаются следующие символы преобразования:

d - на вводе ожидается десятичное целое; соответствующий ар-
   гумент должен быть указателем на целое.
o - На вводе ожидается восьмеричное целое (с лидирующим ну-
   лем или без него); соответствующий аргумент должен быть
   указателем на целое.
x - На вводе ожидается шестнадцатеричное целое (с лидирующи-
   ми 0x или без них); соответствующий аргумент должен быть
   указателем на целое.
h - На вводе ожидается целое типа short; соответсвующий ар-
   гумент должен быть указателем на целое типа short.
c - Ожидается отдельный символ; соответствующий аргумент
   должен быть указателем на символы; следующий вводимый
   символ помещается в указанное место. Обычный пропуск сим-
   волов пустых промежутков в этом случае подавляется; для
   чтения следующего символа, который не является символом
   пустого промежутка, пользуйтесь спецификацией преобразо-
   вания %1s.
s - Ожидается символьная строка; соответствующий аргумент
   должен быть указателем символов, который указывает на
   массив символов, который достаточно велик для принятия
   строки и добавляемого в конце символа \0.
f - Ожидается число с плавающей точкой; соответствующий ар-
   гумент должен быть указателем на переменную типа float.
е - символ преобразования E является синонимом для f. Формат
   ввода переменной типа float включает необязательный знак,
   строку цифр, возможно содержащую десятичную точку и нео-
   бязательное поле экспоненты, состоящее из буквы e, за ко-
   торой следует целое, возможно имеющее знак.

    Перед символами преобразования d, o и x может стоять L,
которая означает , что в списке аргументов должен находиться
указатель на переменную типа long, а не типа int. Аналогич-
но, буква L может стоять перед символами преобразования e
или f, говоря о том, что в списке аргументов должен нахо-
диться указатель на переменную типа double, а не типа float.
    Например, обращение

int i;
float x;
char name[50];
scanf(&quot;%d %f %s&quot;, &amp;i, &amp;x, name);

со строкой на вводе

25  54.32e-1   thompson

приводит к присваиванию i значения 25,x - значения 5.432 и
name - строки &quot;thompson&quot;, надлежащим образом законченной
символом \ 0. Эти три поля ввода можно разделить столькими
пробелами, табуляциями и символами новых строк, сколько вы
пожелаете. Обращение

 int  i;
 float x;
 char name[50];
 scanf(&quot;%2d %f %*d %2s&quot;, &amp;i, &amp;x, name);

с вводом

 56789 0123 45a72

присвоит i значение 56, x - 789.0, пропустит 0123 и поместит
в name строку &quot;45&quot;. при следующем обращении к любой процеду-
ре ввода рассмотрение начнется с буквы a. В этих двух приме-
рах name является указателем и, следовательно, перед ним не
нужно помещать знак &amp;.
    В качестве другого примера перепишем теперь элементарный
калькулятор из главы 4, используя для преобразования ввода
функцию scanf:

#include  &lt;stdio.h&gt;
main()    /* rudimentary desk calculator */
{
  double sum, v;
  sum =0;
  while (scanf(&quot;%lf&quot;, &amp;v) !=EOF)
       printf(&quot;\t%.2f\n&quot;, sum += v);
}

выполнение функции scanf заканчивается либо тогда, когда она
исчерпывает свою управляющую строку, либо когда некоторый
элемент ввода не совпадает с управляющей спецификацией. В
качестве своего значения она возвращает число правильно сов-
падающих и присвоенных элементов ввода. Это число может быть
использовано для определения количества найденных элементов
ввода. При выходе на конец файла возвращается EOF; подчерк-
нем, что это значение отлично от 0, что следующий вводимый
символ не удовлетворяет первой спецификации в управляющей
строке. При следующем обращении к scanf поиск возобновляется
непосредственно за последним введенным символом.
    Заключительное предостережение: аргументы функции scanf
должны быть указателями. Несомненно наиболее распространен-
ная ошибка состоит в написании

 scanf(&quot;%d&quot;, n);

вместо

 scanf(&quot;%d&quot;, &amp;n);</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>
