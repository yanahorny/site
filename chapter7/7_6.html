<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=windows-1251">
		<meta name="Description" content="K&R, 1st ed., 1978. Russian translation by <unknown>; chm-compiling by Sim&C, Belarus`2006">
   		<title>7.6 Доступ к файлам</title>
		<link href="../style.css" rel="stylesheet" type="text/css" media="all">
	</head>

	<body>
	<script  language=JavaScript  src="../header.js"></script>
	<pre>    Все до сих пор написанные программы читали из стандарт-
ного ввода и писали в стандартный вывод, относительно кото-
рых мы предполагали, что они магическим образом предоставле-
ны программе местной операционной системой.
    Следующим шагом в вопросе ввода-вывода является написа-
ние программы, работающей с файлом, который не связан зара-
нее с программой. Одной из программ, которая явно демонстри-
рует потребность в таких операциях, является cat, которая
объединяет набор из нескольких именованных файлов в стандар-
тный вывод. Программа cat используется для вывода файлов на
терминал и в качестве универсального сборщика ввода для
программ, которые не имеют возможности обращаться к файлам
по имени. Например, команда

cat x.c.y.c

печатает содержимое файлов x.c и y.c в стандартный вывод.
    Вопрос состоит в том, как организовать чтение из имено-
ванных файлов, т.е., как связать внешние имена, которыми
мыслит пользователь, с фактически читающими данные операто-
рами.
    Эти правила просты. Прежде чем можно считывать из неко-
торого файла или записывать в него, этот файл должен быть
открыт с помощью функции fopen из стандартной библиотеки.
функция fopen берет внешнее имя (подобное x.c или y.c), про-
водит некоторые обслуживающие действия и переговоры с опера-
ционной системой (детали которых не должны нас касаться) и
возвращает внутреннее имя, которое должно использоваться при
последующих чтениях из файла или записях в него.
    Это внутреннее имя, называемое &quot;указателем файла&quot;, фак-
тически является указателем структуры, которая содержит ин-
формацию о файле, такую как место размещения буфера, текущая
позиция символа в буфере, происходит ли чтение из файла или
запись в него и тому подобное. Пользователи не обязаны знать
эти детали, потому что среди определений для стандартного
ввода-вывода, получаемых из файла stdio.h, содержится опре-
деление структуры с именем FILE. Единственное необходимое
для указателя файла описание демонстрируется примером:

        FILE *fopen(), *fp;

    Здесь говорится, что fp является указателем на FILE и
fopen возвращает указатель на FILE. Oбратите внимание, что
FILE является именем типа, подобным int, а не ярлыку струк-
туры; это реализовано как typedef. (Подробности того, как
все это работает на системе UNIX, приведены в главе 8).
    Фактическое обращение к функции fopen в программе имеет
вид:
       fp=fopen(name,mode);

  Первым аргументом функции fopen является &quot;имя&quot; файла, кото-
рое задается в виде символьной строки. Второй аргумент MODE
(&quot;режим&quot;) также является символьной строкой, которая указы-
вает, как этот файл будет использоваться. Допустимыми режи-
мами являются: чтение (&quot;r&quot;), запись (&quot;w&quot;) и добавление
(&quot;a&quot;).
 Если вы откроете файл, который еще не существует, для за-
 писи или добавления, то такой файл будет создан (если это
возможно). Открытие существующего файла на запись приводит к
отбрасыванию его старого содержимого. Попытка чтения несу-
ществующего файла является ощибкой. Ошибки могут быть обус-
 ловлены и другими причинами (например, попыткой чтения из
 файла, не имея на то разрешения). При наличии какой-либо
 ошибки функция возвращает нулевое значение указателя NULL
(которое для удобства также определяется в файле stdio.h).
  Другой необходимой вещью является способ чтения или за-
писи, если файл уже открыт. Здесь имеется несколько возмож-
ностей, из которых getc и putc являются простейшими. Функция
getc возвращает следующий символ из файла; ей необходим ука-
затель файла, чтобы знать, из какого файла читать. Таким об-
разом,

  c=getc(fp)

помещает в c следующий символ из файла, указанного посред-
ством fp, и EOF, если достигнут конец файла.
    Функция putc, являющаяся обращением к функции getc,

   putc(c,fp)

помещает символ c в файл fp и возвращает c. Подобно фун-
кциям getchar и putchar, getc и putc могут быть макросами, а
не функциями.
    При запуске программы автоматически открываются три фай-
ла, которые снабжены определенными указателями файлов. Этими
файлами являются стандартный ввод, стандартный вывод и стан-
дартный вывод ошибок; соответствующие указатели файлов назы-
ваются stdin, stdout и stderr. Обычно все эти указатели свя-
заны с терминалом, но stdin и stdout могут быть перенаправ-
лены на файлы или в поток (pipe), как описывалось в разделе
7.2.
    Функции getchar и putchar могут быть определены в терми-
налах getc, putc, stdin и stdout следующим образом:

#define getchar() getc(stdin)
#define putchar(c)  putc(c, stdout)

При работе с файлами для форматного ввода и вывода можно ис-
пользовать функции fscanf и fprintf. Они идентичны функциям
scanf и printf, за исключением того, что первым аргументом
является указатель файла, определяющий тот файл, который бу-
дет читаться или куда будет вестись запись; управляющая
строка будет вторым аргументом.
    Покончив с предварительными замечаниями, мы теперь в
состоянии написать программу cat для конкатенации файлов.
Используемая здесь основная схема оказывается удобной во
многих программах: если имеются аргументы в командной стро-
ке, то они обрабатываются последовательно. Если такие аргу-
менты отсутствуют, то обрабатывается стандартный ввод. Это
позволяет использовать программу как самостоятельно, так и
как часть большей задачи.

#include &lt;stdio.h&gt;

main(argc, argv)   /*cat: concatenate files*/
int argc;
char *argv[];
{
  FILE *fp, *fopen();
  if(argc==1) /*no args; copy standard input*/
    filecopy(stdin);
  else
    while (--argc &gt; 0)
      if ((fp=fopen(*++argv,&quot;r&quot;))==NULL) {
        printf(&quot;cat:can't open %\n&quot;,*argv);
        break;
      }
      else {
        filecopy(fp);
        fclose(fp);
      }
}

filecopy(fp)  /*copy file fp to standard output*/
file *fp;
{
  int c;
  while ((c=getc(fp)) !=EOF)
    putc(c, stdout);
}

Указатели файлов stdin и stdout заранее определены в библио-
теке ввода-вывода как стандартный ввод и стандартный вывод;
они могут быть использованы в любом месте, где можно исполь-
зовать объект типа FILE*. Они однако являются константами, а
не переменными, так что не пытайтесь им что-либо присваи-
вать.
    Функция fclose является обратной по отношению к fopen;
она разрывает связь между указателем файла и внешним именем,
установленную функцией fopen, и высвобождает указатель файла
для другого файла. Большинство операционных систем имеют не-
которые ограничения на число одновременно открытых файлов,
которыми может распоряжаться программа. Поэтому, то как мы
поступили в cat, освободив не нужные нам более объекты, яв-
ляется хорошей идеей. Имеется и другая причина для примене-
ния функции fclose к выходному файлу - она вызывает выдачу
информации из буфера, в котором putc собирает вывод. (При
нормальном завершении работы программы функция fclose вызы-
вается автоматически для каждого открытого файла).
</pre>
	<script  language=JavaScript  src="../footer.js"></script>
	</body>
	
</html>